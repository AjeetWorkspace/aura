{"version":3,"file":"engine_compat.min.js","sources":["../src/framework/language.ts","../src/framework/class-list.ts","../src/framework/context.ts","../src/framework/utils.ts","../src/framework/services.ts","../src/framework/hook.ts","../src/framework/api.ts","../src/framework/watcher.ts","../src/framework/properties.ts","../src/framework/template.ts","../src/framework/defer.ts","../src/framework/invoker.ts","../src/framework/component.ts","../src/framework/compat.ts","../src/framework/membrane.ts","../src/framework/piercing.ts","../src/framework/root.ts","../src/framework/html-element.ts","../src/framework/def.ts","../src/framework/vm.ts","../src/framework/modules/component-init.ts","../src/framework/modules/component-props.ts","../src/framework/modules/component-attrs.ts","../src/framework/modules/component-events.ts","../src/framework/modules/component-classes.ts","../src/framework/modules/component-slotset.ts","../src/framework/modules/component-children.ts","../src/framework/modules/props.ts","../src/3rdparty/snabbdom/is.ts","../src/3rdparty/snabbdom/htmldomapi.ts","../src/3rdparty/snabbdom/snabbdom.ts","../src/framework/modules/attrs.ts","../src/framework/modules/styles.ts","../src/framework/modules/classes.ts","../src/framework/modules/events.ts","../src/framework/modules/uid.ts","../src/framework/upgrade.ts","../src/framework/dom.ts","../src/framework/patch.ts"],"sourcesContent":["const {\n    freeze,\n    seal,\n    keys,\n    create,\n    assign,\n    defineProperty,\n    getPrototypeOf,\n    setPrototypeOf,\n    getOwnPropertyDescriptor,\n    getOwnPropertyNames,\n    defineProperties,\n    getOwnPropertySymbols,\n    hasOwnProperty,\n} = Object;\nconst isArray = Array.isArray;\nconst {\n    filter: ArrayFilter,\n    slice: ArraySlice,\n    splice: ArraySplice,\n    indexOf: ArrayIndexOf,\n    push: ArrayPush,\n    map: ArrayMap,\n    forEach,\n} = Array.prototype;\n\nexport {\n    freeze,\n    seal,\n    keys,\n    create,\n    assign,\n    defineProperty,\n    defineProperties,\n    getPrototypeOf,\n    setPrototypeOf,\n    getOwnPropertyDescriptor,\n    getOwnPropertyNames,\n    getOwnPropertySymbols,\n    hasOwnProperty,\n    ArraySlice,\n    ArraySplice,\n    ArrayFilter,\n    ArrayMap,\n    isArray,\n    ArrayIndexOf,\n    ArrayPush,\n    forEach,\n}\n\nexport function isUndefined(obj: any): boolean {\n    return obj === undefined;\n}\n\nexport function isNull(obj: any): boolean {\n    return obj === null;\n}\n\nexport function isTrue(obj: any): boolean {\n    return obj === true;\n}\n\nexport function isFunction(obj: any): boolean {\n    return typeof obj === 'function';\n}\nexport function isObject(obj: any): boolean {\n    return typeof obj === 'object';\n}\n\nexport function isString(obj: any): boolean {\n    return typeof obj === 'string';\n}\n\nexport function isNumber(obj: any): boolean {\n    return typeof obj === 'number';\n}\n\nexport function isPromise(obj: any): boolean {\n    return typeof obj === 'object' && obj === Promise.resolve(obj);\n}\n\nconst OtS = {}.toString;\nexport function toString(obj: any): string {\n    if (obj && typeof obj === 'object' && !obj.toString) {\n        return OtS.call(obj);\n    }\n    return obj + '';\n}\n\nexport function bind(fn: Function, ctx: Object): Function {\n    function boundFn(a: any): any {\n        const l = arguments.length\n        return l\n            ? l > 1\n                ? fn.apply(ctx, arguments)\n                : fn.call(ctx, a)\n            : fn.call(ctx)\n    }\n    return boundFn;\n}\n","import assert from \"./assert\";\nimport {\n    getOwnPropertyNames,\n    defineProperty,\n    isUndefined,\n    forEach,\n} from \"./language\";\n\nimport { ViewModelReflection } from \"./html-element\";\n\nfunction getLinkedElement(classList: ClassList): HTMLElement {\n    return classList[ViewModelReflection].vnode.elm;\n}\n\n// This needs some more work. ClassList is a weird DOM api because it\n// is a TokenList, but not an Array. For now, we are just implementing\n// the simplest one.\n// https://www.w3.org/TR/dom/#domtokenlist\nexport function ClassList(vm: VM): DOMTokenList {\n    assert.vm(vm);\n    defineProperty(this, ViewModelReflection, {\n        value: vm,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n    });\n}\n\nClassList.prototype = {\n    add() {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        const elm = getLinkedElement(this);\n        // Add specified class values. If these classes already exist in attribute of the element, then they are ignored.\n        forEach.call(arguments, (className: String) => {\n            className = className + '';\n            if (!cmpClasses[className]) {\n                cmpClasses[className] = true;\n                // this is not only an optimization, it is also needed to avoid adding the same\n                // class twice when the initial diffing algo kicks in without an old vm to track\n                // what was already added to the DOM.\n                if (vm.idx) {\n                    // we intentionally make a sync mutation here and also keep track of the mutation\n                    // for a possible rehydration later on without having to rehydrate just now.\n                    elm.classList.add(className);\n                }\n            }\n        });\n    },\n    remove() {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        const elm = getLinkedElement(this);\n        // Remove specified class values.\n        forEach.call(arguments, (className: String) => {\n            className = className + '';\n            if (cmpClasses[className]) {\n                cmpClasses[className] = false;\n                // this is not only an optimization, it is also needed to avoid removing the same\n                // class twice when the initial diffing algo kicks in without an old vm to track\n                // what was already added to the DOM.\n                if (vm.idx) {\n                    // we intentionally make a sync mutation here when needed and also keep track of the mutation\n                    // for a possible rehydration later on without having to rehydrate just now.\n                    const ownerClass = vm.vnode.data.class;\n                    // This is only needed if the owner is not forcing that class to be present in case of conflicts.\n                    if (isUndefined(ownerClass) || !ownerClass[className]) {\n                        elm.classList.remove(className);\n                    }\n                }\n            }\n        });\n    },\n    item(index: Number): string | void {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        // Return class value by index in collection.\n        return getOwnPropertyNames(cmpClasses)\n            .filter((className: string): boolean => cmpClasses[className + ''])[index] || null;\n    },\n    toggle(className: String, force: any): boolean {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        // When only one argument is present: Toggle class value; i.e., if class exists then remove it and return false, if not, then add it and return true.\n        // When a second argument is present: If the second argument evaluates to true, add specified class value, and if it evaluates to false, remove it.\n        if (arguments.length > 1) {\n            if (force) {\n                this.add(className);\n            } else if (!force) {\n                this.remove(className);\n            }\n            return !!force;\n        }\n        if (cmpClasses[className]) {\n            this.remove(className);\n            return false;\n        }\n        this.add(className);\n        return true;\n    },\n    contains(className: String): boolean {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        // Checks if specified class value exists in class attribute of the element.\n        return !!cmpClasses[className];\n    },\n    toString(): string {\n        const vm = this[ViewModelReflection];\n        const { cmpClasses } = vm;\n        return getOwnPropertyNames(cmpClasses).filter((className: string): boolean => cmpClasses[className + '']).join(' ');\n    }\n};\n","const topLevelContextSymbol = Symbol('Top Level Context');\n\nexport let currentContext = {};\n\ncurrentContext[topLevelContextSymbol] = true;\n\nexport function establishContext(ctx: Object) {\n    currentContext = ctx;\n}\n","import assert from \"./assert\";\nimport { create, seal, ArrayPush, freeze, isFunction } from \"./language\";\n\nlet nextTickCallbackQueue: Array<Callback> = [];\nconst SPACE_CHAR = 32;\n\nexport let EmptyObject = seal(create(null));\n\nfunction flushCallbackQueue() {\n    assert.invariant(nextTickCallbackQueue.length, `If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue instead of ${nextTickCallbackQueue}.`);\n    const callbacks: Array<Callback> = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\n\nexport function addCallbackToNextTick(callback: Callback) {\n    assert.isTrue(isFunction(callback), `addCallbackToNextTick() can only accept a function callback as first argument instead of ${callback}`);\n    if (nextTickCallbackQueue.length === 0) {\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    // TODO: eventually, we might want to have priority when inserting callbacks\n    ArrayPush.call(nextTickCallbackQueue, callback);\n}\n\nconst CAMEL_REGEX = /-([a-z])/g;\nconst attrNameToPropNameMap = create(null);\n\nexport function getPropNameFromAttrName(attrName: string): string {\n    let propName = attrNameToPropNameMap[attrName];\n    if (!propName) {\n        propName = attrName.replace(CAMEL_REGEX, (g: string): string => g[1].toUpperCase());\n        attrNameToPropNameMap[attrName] = propName;\n    }\n    return propName;\n}\n\nconst CAPS_REGEX = /[A-Z]/g;\nimport {\n    HTMLPropertyNamesWithLowercasedReflectiveAttributes,\n} from \"./dom\";\n\n/**\n * This dictionary contains the mapping between property names\n * and the corresponding attribute name. This helps to trigger observable attributes.\n */\nconst propNameToAttributeNameMap = {\n    // these are exceptions to the rule that cannot be inferred via `CAPS_REGEX`\n    className: 'class',\n    htmlFor: 'for',\n};\n// Few more exceptions where the attribute name matches the property in lowercase.\nHTMLPropertyNamesWithLowercasedReflectiveAttributes.forEach((propName: string) => {\n    propNameToAttributeNameMap[propName] = propName.toLowerCase();\n});\n\nexport function getAttrNameFromPropName(propName: string): string {\n    let attrName = propNameToAttributeNameMap[propName];\n    if (!attrName) {\n        attrName = propName.replace(CAPS_REGEX, (match: string): string => '-' + match.toLowerCase());\n        propNameToAttributeNameMap[propName] = attrName;\n    }\n    return attrName;\n}\n\nexport function toAttributeValue(raw: any): string | null {\n    // normalizing attrs from compiler into HTML global attributes\n    if (raw === true) {\n        raw = '';\n    } else if (raw === false) {\n        raw = null;\n    }\n    return raw !== null ? raw + '' : null;\n}\n\nexport function noop() {}\n\nconst classNameToClassMap = create(null);\n\nexport function getMapFromClassName(className: string): HashTable<boolean> {\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = {};\n    let start = 0;\n    let i, len = className.length;\n    for (i = 0; i < len; i++) {\n        if (className.charCodeAt(i) === SPACE_CHAR) {\n            if (i > start) {\n                map[className.slice(start, i)] = true;\n            }\n            start = i + 1;\n        }\n    }\n\n    if (i > start) {\n        map[className.slice(start, i)] = true;\n    }\n    classNameToClassMap[className] = map;\n    assert.block(() => {\n        // just to make sure that this object never changes as part of the diffing algo\n        freeze(map);\n    });\n    return map;\n}\n","import assert from \"./assert\";\nimport { isUndefined, isObject, isArray, create } from \"./language\";\n\nconst hooks = ['wiring', 'rehydrated', 'connected', 'disconnected', 'piercing'];\n\n/* eslint-disable */\nimport { Replicable } from \"./membrane\";\nexport type ServiceCallback = (component: Component, data: VNodeData, def: ComponentDef, context: HashTable<any>) => void;\nexport type MembranePiercingCallback = (component: Component, data: VNodeData, def: ComponentDef, context: HashTable<any>, target: Replicable, key: Symbol | string, value: any, callback: (newValue?: any) => void) => void;\nexport type ServiceDef = { wiring?: ServiceCallback; connected?: ServiceCallback; disconnected?: ServiceCallback; rehydrated?: ServiceCallback; piercing?: MembranePiercingCallback; [key: string]: ServiceCallback | MembranePiercingCallback | undefined; };\n/* eslint-enable */\n\nexport const Services: {\n  wiring?: ServiceCallback[];\n  connected?: ServiceCallback[];\n  disconnected?: ServiceCallback[];\n  rehydrated?: ServiceCallback[];\n  piercing?: MembranePiercingCallback[];\n  [key: string]: ServiceCallback[] | MembranePiercingCallback[] | undefined;\n} = create(null);\n\nexport function register(service: ServiceDef) {\n    assert.isTrue(isObject(service), `Invalid service declaration, ${service}: service must be an object`);\n    for (let i = 0; i < hooks.length; ++i) {\n        const hookName = hooks[i];\n        if (hookName in service) {\n            let l = Services[hookName];\n            if (isUndefined(l)) {\n                Services[hookName] = l = [];\n            }\n\n            l.push(service[hookName]);\n        }\n    }\n}\n\nexport function invokeServiceHook(vm: VM, cbs: Array<ServiceCallback>) {\n    assert.vm(vm);\n    assert.isTrue(isArray(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n    const { component, vnode: { data }, def, context } = vm;\n    for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].call(undefined, component, data, def, context);\n    }\n}\n","import assert from \"./assert\";\nimport { invokeComponentMethod } from \"./invoker\";\nimport { clearListeners } from \"./component\";\nimport { rehydrate, addInsertionIndex, removeInsertionIndex } from \"./vm\";\nimport { addCallbackToNextTick, noop } from \"./utils\";\nimport { invokeServiceHook, Services } from \"./services\";\n\nfunction insert(vnode: ComponentVNode) {\n    assert.vnode(vnode);\n    const { vm } = vnode;\n    assert.vm(vm);\n    assert.isFalse(vm.idx, `${vm} is already inserted.`);\n    addInsertionIndex(vm);\n    const { isDirty, component: { connectedCallback } } = vm;\n    if (isDirty) {\n        // this code path guarantess that when patching the custom element for the first time,\n        // the body is computed only after the element is in the DOM, otherwise the hooks\n        // for any children's vnode are not going to be useful.\n        rehydrate(vm);\n    }\n    const { connected } = Services;\n    if (connected) {\n        addCallbackToNextTick((): void => invokeServiceHook(vm, connected));\n    }\n    if (connectedCallback && connectedCallback !== noop) {\n        addCallbackToNextTick((): void => invokeComponentMethod(vm, 'connectedCallback'));\n    }\n    console.log(`\"${vm}\" was inserted.`);\n}\n\nfunction destroy(vnode: ComponentVNode) {\n    assert.vnode(vnode);\n    const { vm } = vnode;\n    assert.vm(vm);\n    assert.isTrue(vm.idx, `${vm} is not inserted.`);\n    removeInsertionIndex(vm);\n    // just in case it comes back, with this we guarantee re-rendering it\n    vm.isDirty = true;\n    const { disconnected } = Services;\n    const { component: { disconnectedCallback } } = vm;\n    clearListeners(vm);\n    if (disconnected) {\n        addCallbackToNextTick((): void => invokeServiceHook(vm, disconnected));\n    }\n    if (disconnectedCallback && disconnectedCallback !== noop) {\n        addCallbackToNextTick((): void => invokeComponentMethod(vm, 'disconnectedCallback'));\n    }\n    console.log(`\"${vm}\" was destroyed.`);\n}\n\nfunction postpatch(oldVnode: VNode, vnode: ComponentVNode) {\n    assert.vnode(vnode);\n    assert.vm(vnode.vm);\n    if (vnode.vm.idx === 0) {\n        // when inserting a root element, or when reusing a DOM element for a new\n        // component instance, the insert() hook is never called because the element\n        // was already in the DOM before creating the instance, and diffing the\n        // vnode, for that, we wait until the patching process has finished, and we\n        // use the postpatch() hook to trigger the connectedCallback logic.\n        insert(vnode);\n        // Note: we don't have to worry about destroy() hook being called before this\n        // one because they never happen in the same patching mechanism, only one\n        // of them is called. In the case of the insert() hook, we use the value of `idx`\n        // to dedupe the calls since they both can happen in the same patching process.\n    }\n}\n\nexport const lifeCycleHooks = {\n    insert,\n    destroy,\n    postpatch,\n}\n","import assert from \"./assert\";\nimport { lifeCycleHooks as hook } from \"./hook\";\nimport { isArray, create, isUndefined, isFunction, isObject, isString, toString, ArrayPush } from \"./language\";\nimport { vmBeingRendered, invokeComponentCallback } from \"./invoker\";\nimport { getMapFromClassName } from \"./utils\";\n\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst EmptyData = create(null);\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\n\nfunction addNS(data: any, children: Array<VNode> | undefined, sel: string | undefined) {\n    data.ns = NamespaceAttributeForSVG;\n    if (isUndefined(children) || sel === 'foreignObject') {\n        return;\n    }\n    const len = children.length;\n    for (let i = 0; i < len; ++i) {\n        const child = children[i];\n        let { data } = child;\n        if (data !== undefined) {\n            const grandChildren: Array<VNode> = child.children;\n            addNS(data, grandChildren, child.sel);\n        }\n    }\n}\n\n// [v]node node\nexport function v(sel: string | undefined, data: VNodeData | undefined, children: Array<VNode | string> | undefined, text?: string | number | undefined, elm?: Element | Text | undefined, Ctor?: Class<Component>): VNode {\n    data = data || EmptyData;\n    let { key } = data;\n    // Try to identify the owner, but for root elements and other special cases, we\n    // can just fallback to 0 which means top level creation.\n    const uid = vmBeingRendered ? vmBeingRendered.uid : 0;\n    const vnode: VNode = { sel, data, children, text, elm, key, Ctor, uid };\n    assert.block(function devModeCheck() {\n        // adding toString to all vnodes for debuggability\n        vnode.toString = (): string => `[object:vnode ${sel}]`;\n    });\n    return vnode;\n}\n\n// [h]tml node\nexport function h(sel: string, data: VNodeData, children: Array<any>): VNode {\n    assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n    assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);\n    assert.isTrue(isArray(children), `h() 3rd argument children must be an array.`);\n    // checking reserved internal data properties\n    assert.invariant(data.class === undefined, `vnode.data.class should be undefined when calling h().`);\n    const { classMap, className } = data;\n    assert.isFalse(className && classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    data.class = classMap || (className && getMapFromClassName(className));\n    assert.block(function devModeCheck() {\n        children.forEach((vnode) => {\n            if (vnode === null) {\n                return;\n            }\n            assert.vnode(vnode);\n        });\n    });\n    if (sel.length === 3 && sel.charCodeAt(0) === CHAR_S && sel.charCodeAt(1) === CHAR_V && sel.charCodeAt(2) === CHAR_G) {\n        addNS(data, children, sel);\n    }\n    return v(sel, data, children);\n}\n\n// [c]ustom element node\nexport function c(sel: string, Ctor: Class<Component>, data: VNodeData): VNode {\n    // The compiler produce AMD modules that do not support circular dependencies\n    // We need to create an indirection to circumvent those cases.\n    // We could potentially move this check to the definition\n    if (Ctor.__circular__) {\n        Ctor = Ctor();\n    }\n\n    assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n    assert.isTrue(isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);\n    assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);\n        // checking reserved internal data properties\n    assert.invariant(data.class === undefined, `vnode.data.class should be undefined when calling c().`);\n    const { key, slotset, attrs, on, className, classMap, props: _props } = data;\n    assert.isTrue(arguments.length < 4, `Compiler Issue: Custom elements expect up to 3 arguments, received ${arguments.length} instead.`);\n    data = { hook, key, slotset, attrs, on, _props };\n    assert.isFalse(className && classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n    data.class = classMap || (className && getMapFromClassName(className));\n    return v(sel, data, [], undefined, undefined, Ctor);\n}\n\n// [i]terable node\nexport function i(items: Array<any>, factory: Function): Array<VNode> {\n    const len = isArray(items) ? items.length : 0;\n    const list: Array<VNode> = [];\n    for (let i = 0; i < len; i += 1) {\n        const vnode = factory(items[i], i, i === 0, i === len);\n        if (isArray(vnode)) {\n            ArrayPush.apply(list, vnode);\n        } else {\n            ArrayPush.call(list, vnode);\n        }\n        assert.block(function devModeCheck() {\n            const vnodes = isArray(vnode) ? vnode : [vnode];\n            vnodes.forEach((vnode: VNode | any) => {\n                if (vnode && isObject(vnode) && vnode.sel && vnode.Ctor && isUndefined(vnode.key)) {\n                    // TODO - it'd be nice to log the owner component rather than the iteration children\n                    assert.logWarning(`Missing \"key\" attribute in iteration with child \"${toString(vnode.Ctor.name)}\", index ${i} of ${len}. Instead set a unique \"key\" attribute value on all iteration children so internal state can be preserved during rehydration.`);\n                }\n            });\n        });\n    }\n    return list;\n}\n\n/**\n * [f]lattening\n */\nexport function f(items: Array<any>): Array<any> {\n    assert.isTrue(isArray(items), 'flattening api can only work with arrays.');\n    const len = items.length;\n    const flattened: Array<VNode|null|number|string> = [];\n    for (let i = 0; i < len; i += 1) {\n        const item = items[i];\n        if (isArray(item)) {\n            ArrayPush.apply(flattened, item);\n        } else {\n            ArrayPush.call(flattened, item);\n        }\n    }\n    return flattened;\n}\n\n// [t]ext node\nexport function t(value: string | number): VNode {\n    return v(undefined, undefined, undefined, value);\n}\n\n// [d]ynamic value to produce a text vnode\nexport function d(value: any): VNode | null {\n    if (value === undefined || value === null) {\n        return null;\n    }\n    return v(undefined, undefined, undefined, value);\n}\n\n// [b]ind function\nexport function b(fn: EventListener): EventListener {\n    assert.vm(vmBeingRendered);\n    function handler(event: Event) {\n        // TODO: only if the event is `composed` it can be dispatched\n        invokeComponentCallback(handler.vm, handler.fn, handler.vm.component, [event]);\n    }\n    handler.vm = vmBeingRendered;\n    handler.fn = fn;\n    return handler;\n}\n","import assert from \"./assert\";\nimport { scheduleRehydration } from \"./vm\";\nimport { markComponentAsDirty } from \"./component\";\nimport { isUndefined, toString, create, ArrayIndexOf, ArrayPush } from \"./language\";\n\nconst TargetToReactiveRecordMap: Map<Object, ReactiveRecord> = new WeakMap();\n\nexport function notifyListeners(target: Object, key: string | Symbol) {\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (reactiveRecord) {\n        const value = reactiveRecord[key];\n        if (value) {\n            const len = value.length;\n            for (let i = 0; i < len; i += 1) {\n                const vm = value[i];\n                assert.vm(vm);\n                console.log(`Marking ${vm} as dirty: property \"${toString(key)}\" of ${toString(target)} was set to a new value.`);\n                if (!vm.isDirty) {\n                    markComponentAsDirty(vm);\n                    console.log(`Scheduling ${vm} for rehydration due to mutation.`);\n                    scheduleRehydration(vm);\n                }\n            }\n        }\n    }\n}\n\nexport function subscribeToSetHook(vm: VM, target: Object, key: string | Symbol) {\n    assert.vm(vm);\n    let reactiveRecord: ReactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (isUndefined(reactiveRecord)) {\n        const newRecord: ReactiveRecord = create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    let value = reactiveRecord[key];\n    if (isUndefined(value)) {\n        value = [];\n        reactiveRecord[key] = value;\n    }\n    if (ArrayIndexOf.call(value, vm) === -1) {\n        ArrayPush.call(value, vm);\n        // we keep track of the sets that vm is listening from to be able to do some clean up later on\n        ArrayPush.call(vm.deps, value);\n    }\n}\n","import assert from \"./assert\";\nimport {\n    subscribeToSetHook,\n    notifyListeners,\n} from \"./watcher\";\nimport {\n    isRendering,\n    vmBeingRendered,\n} from \"./invoker\";\nimport { isUndefined, defineProperty, hasOwnProperty, toString, isArray, isObject, isNull } from \"./language\";\n\nconst ObjectPropertyToProxyCache: WeakMap<Object, Object> = new WeakMap();\nconst ProxyCache: WeakSet<Object> = new WeakSet(); // used to identify any proxy created by this piece of logic.\n\nfunction propertyGetter(target: Object, key: string | Symbol): any {\n    const value = target[key];\n    if (isRendering && vmBeingRendered) {\n        subscribeToSetHook(vmBeingRendered, target, key);\n    }\n    return (value && isObject(value)) ? getPropertyProxy(value) : value;\n}\n\nfunction propertySetter(target: Object, key: string | Symbol, value: any): boolean {\n    if (isRendering) {\n        assert.logError(`Setting property \"${toString(key)}\" of ${toString(target)} during the rendering process of ${vmBeingRendered} is invalid. The render phase must have no side effects on the state of any component.`);\n        return false;\n    }\n    const oldValue = target[key];\n    if (oldValue !== value) {\n        target[key] = value;\n        notifyListeners(target, key);\n    } else if (key === 'length' && isArray(target)) {\n        // fix for issue #236: push will add the new index, and by the time length\n        // is updated, the internal length is already equal to the new length value\n        // therefore, the oldValue is equal to the value. This is the forking logic\n        // to support this use case.\n        notifyListeners(target, key);\n    }\n    return true;\n}\n\nfunction propertyDelete(target: Object, key: string | Symbol): boolean {\n    delete target[key];\n    notifyListeners(target, key);\n    return true;\n}\n\nconst propertyProxyHandler = {\n    get: propertyGetter,\n    set: propertySetter,\n    deleteProperty: propertyDelete,\n};\n\nexport function getPropertyProxy(value: Object): any {\n    assert.isTrue(isObject(value), \"perf-optimization: avoid calling this method for non-object value.\");\n\n    // TODO: Provide a holistic way to deal with built-ins, right now we just care ignore Date\n    if (isNull(value) || value.constructor === Date) {\n        return value;\n    }\n    // TODO: perf opt - we should try to give identity to propertyProxies so we can test\n    // them faster than a weakmap lookup.\n    if (ProxyCache.has(value)) {\n        return value;\n    }\n\n    assert.block(function devModeCheck() {\n        const isNode = value instanceof Node;\n        assert.invariant(!isNode, `Do not store references to DOM Nodes. Instead use \\`this.querySelector()\\` and \\`this.querySelectorAll()\\` to find the nodes when needed.`);\n    });\n\n    let proxy = ObjectPropertyToProxyCache.get(value);\n    if (proxy) {\n        return proxy;\n    }\n    proxy = new Proxy(value, propertyProxyHandler);\n    ObjectPropertyToProxyCache.set(value, proxy);\n    ProxyCache.add(proxy);\n    return proxy;\n}\nconst InstanceField = 0;\nconst RegularField = 1;\nconst ExpandoField = 2;\nconst MutatedField = 3;\nconst ObjectToFieldsMap = new WeakMap();\n\nexport function extractOwnFields(component: Object, allowInstanceFields: boolean): HashTable<number> {\n    let fields = ObjectToFieldsMap.get(component);\n    let type = allowInstanceFields ? InstanceField : ExpandoField;\n    if (isUndefined(fields)) {\n        // only the first batch are considered private fields\n        type = RegularField;\n        fields = {};\n        ObjectToFieldsMap.set(component, fields);\n    }\n    for (let propName in component) {\n        if (hasOwnProperty.call(component, propName) && isUndefined(fields[propName])) {\n            fields[propName] = type;\n            let value = component[propName];\n\n            if (!allowInstanceFields) {\n                // replacing the field with a getter and a setter to track the mutations\n                // and provide meaningful errors\n                defineProperty(component, propName, {\n                    get: (): any => value,\n                    set: (newValue: any) => {\n                        value = newValue;\n                        fields[propName] = MutatedField;\n                    },\n                    configurable: false,\n                });\n            }\n        }\n    }\n    return fields;\n}\n\nexport function getOwnFields(target: Object): HashTable<number> {\n    let fields = ObjectToFieldsMap.get(target);\n    if (isUndefined(fields)) {\n        fields = {};\n    }\n    return fields;\n}\n","import assert from \"./assert\";\nimport * as api from \"./api\";\nimport { isArray, isFunction, isObject, create, ArrayIndexOf, toString, hasOwnProperty } from \"./language\";\nimport { getOwnFields, extractOwnFields } from \"./properties\";\nimport { vmBeingRendered } from \"./invoker\";\nimport { subscribeToSetHook } from \"./watcher\";\n\nconst EmptySlots = create(null);\n\nfunction getSlotsetValue(slotset: HashTable<Array<VNodes>>, slotName: string): Array<VNodes> {\n    assert.isTrue(isObject(slotset), `Invalid slotset value ${toString(slotset)}`);\n    // TODO: mark slotName as reactive\n    return slotset && slotset[slotName];\n}\n\nconst slotsetProxyHandler = {\n    get: (slotset: Object, key: string | Symbol): any => getSlotsetValue(slotset, key),\n    set: (): boolean => {\n        assert.invariant(false, `$slotset object cannot be mutated from template.`);\n        return false;\n    },\n    deleteProperty: (): boolean => {\n        assert.invariant(false, `$slotset object cannot be mutated from template.`);\n        return false;\n    },\n};\n\n// we use inception to track down the memoized object for each value used in a template from a component\nlet currentMemoized: HashTable<any> | null = null;\n\nconst cmpProxyHandler = {\n    get: (cmp: Object, key: string | Symbol): any => {\n        assert.invariant(currentMemoized !== null && vmBeingRendered !== null && vmBeingRendered.component === cmp, ` getFieldValue() should only be accessible during rendering phase.`);\n        if (key in currentMemoized) {\n            return currentMemoized[key];\n        }\n        assert.block(function devModeCheck() {\n            if (hasOwnProperty.call(cmp, key)) {\n                const fields = getOwnFields(cmp);\n                switch (fields[key]) {\n                    case 0: break; // Instance fields that have special privileges can go though\n                    case 1:\n                        assert.logError(`${cmp}'s template is accessing \\`this.${toString(key)}\\` directly, which is declared in the constructor and considered a private field. Instead access it via a getter or make it reactive by moving it to \\`this.state.${toString(key)}\\`.`);\n                        break;\n                    case 2:\n                        assert.logError(`${cmp}'s template is accessing \\`this.${toString(key)}\\` directly, which is added as an expando property of the component and considered a private field. Instead access it via a getter or make it reactive by moving it to \\`this.state.${toString(key)}\\`.`);\n                        break;\n                    case 3:\n                        assert.logError(`${cmp}'s template is accessing \\`this.${toString(key)}\\`, which is considered a mutable private field but mutations cannot be observed. Instead move it to \\`this.state.${toString(key)}\\`.`);\n                        break;\n                    default:\n                        // TODO: this should never really happen because the compiler should always validate\n                        console.warn(`${cmp}'s template is accessing \\`this.${toString(key)}\\`, which is not declared by the component. This is likely a typo in the template.`);\n                }\n            }\n        });\n\n        // slow path to access component's properties from template\n        let value;\n        const { cmpState, cmpProps, def: { props: publicPropsConfig } } = (vmBeingRendered as VM); // eslint-disable-line no-undef\n        if (key === 'state' && cmpState) {\n            value = cmpState;\n        } else if (key in publicPropsConfig && key in cmpProps) {\n            subscribeToSetHook(vmBeingRendered as VM, cmpProps, key); // eslint-disable-line no-undef\n            value = cmpProps[key];\n        } else {\n            value = cmp[key];\n        }\n        (currentMemoized as HashTable<any>)[key] = value; // eslint-disable-line no-undef\n        return value;\n    },\n    set: (cmp: Object, key: string | Symbol): boolean => {\n        assert.logError(`Invalid assignment: ${cmp} cannot set a new value for property ${key} during the rendering phase.`);\n        return false;\n    },\n    deleteProperty: (cmp: Object, key: string | Symbol): boolean => {\n        assert.logError(`Invalid delete statement: ${cmp} cannot delete property ${key} during the rendering phase.`);\n        return false;\n    },\n};\n\nexport function evaluateTemplate(vm: VM, html: any): Array<VNode|null> {\n    assert.vm(vm);\n    assert.isTrue(isFunction(html), `evaluateTemplate() second argument must be a function instead of ${html}`);\n    // TODO: add identity to the html functions\n    let { component, context, cmpSlots = EmptySlots, cmpTemplate } = vm;\n    // reset the cache momizer for template when needed\n    if (html !== cmpTemplate) {\n        context.tplCache = create(null);\n        vm.cmpTemplate = html;\n    }\n    assert.isTrue(isObject(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`);\n    assert.block(function devModeCheck() {\n        // before every render, in dev-mode, we will like to know all expandos and\n        // all private-fields-like properties, so we can give meaningful errors.\n        extractOwnFields(component);\n\n        // validating slot names\n        const { slots = [] } = html;\n        for (let slotName in cmpSlots) {\n            if (ArrayIndexOf.call(slots, slotName) === -1) {\n                // TODO: this should never really happen because the compiler should always validate\n                console.warn(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. This is probably a typo on the slot attribute.`);\n            }\n        }\n\n        // validating identifiers used by template that should be provided by the component\n        const { ids = [] } = html;\n        ids.forEach((propName: string) => {\n            if (!(propName in component)) {\n                // TODO: this should never really happen because the compiler should always validate\n                console.warn(`The template rendered by ${vm} references \\`this.${propName}\\`, which is not declared. This is likely a typo in the template.`);\n            }\n        });\n\n    });\n    const { proxy: slotset, revoke: slotsetRevoke } = Proxy.revocable(cmpSlots, slotsetProxyHandler);\n    const { proxy: cmp, revoke: componentRevoke } = Proxy.revocable(component, cmpProxyHandler);\n    const outerMemoized = currentMemoized;\n    currentMemoized = create(null);\n    let vnodes = html.call(undefined, api, cmp, slotset, context.tplCache);\n    assert.invariant(isArray(vnodes), `Compiler should produce html functions that always return an array.`);\n    currentMemoized = outerMemoized; // inception to memoize the accessing of keys from cmp for every render cycle\n    slotsetRevoke();\n    componentRevoke();\n    return vnodes;\n}\n","import assert from \"./assert\";\nimport { isFunction, isUndefined, isPromise } from \"./language\";\nimport { evaluateTemplate } from \"./template\";\nimport { rehydrate } from \"./vm\";\n\nfunction attemptToEvaluateResolvedTemplate(vm: VM, html: Template | undefined, originalPromise: Promise<Template | undefined>) {\n    let { context } = vm;\n    if (originalPromise !== context.tplPromise) {\n        // resolution of an old promise that is not longer relevant, ignoring it.\n        return;\n    }\n    if (isFunction(html)) {\n        context.tplResolvedValue = html;\n        assert.block(function devModeCheck() {\n            if (html === vm.cmpTemplate) {\n                assert.logError(`component ${vm.component} is returning a new promise everytime the render() method is invoked, even though the promise resolves to the same template ${html}. You should cache the promise outside of the render method, and return the same promise everytime, otherwise you will incurr in some performance penalty.`);\n            }\n        });\n        // forcing the vm to be dirty so it can render its content.\n        vm.isDirty = true;\n        rehydrate(vm);\n    } else if (!isUndefined(html)) {\n        assert.fail(`The template rendered by ${vm} must return an imported template tag (e.g.: \\`import html from \"./mytemplate.html\"\\`) or undefined, instead, it has returned ${html}.`);\n    }\n    // if the promise resolves to `undefined`, do nothing...\n}\n\nexport function deferredTemplate(vm: VM, html: Promise<Template | undefined>): Array<VNode> {\n    assert.vm(vm);\n    assert.isTrue(isPromise(html), `deferredTemplate() second argument must be a promise instead of ${html}`);\n    let { context } = vm;\n    const { tplResolvedValue, tplPromise } = context;\n    if (html !== tplPromise) {\n        context.tplPromise = html;\n        context.tplResolvedValue = undefined;\n        html.then((fn) => attemptToEvaluateResolvedTemplate(vm, fn, html));\n    } else if (tplResolvedValue) {\n        // if multiple invokes to render() return the same promise, we can rehydrate using the\n        // underlaying resolved value of that promise.\n        return evaluateTemplate(vm, tplResolvedValue);\n    }\n    return [];\n}\n","import assert from \"./assert\";\nimport {\n    currentContext,\n    establishContext,\n} from \"./context\";\nimport { evaluateTemplate } from \"./template\";\nimport { deferredTemplate } from \"./defer\";\nimport { isUndefined, isFunction, isPromise } from \"./language\";\n\nexport let isRendering: boolean = false;\nexport let vmBeingRendered: VM|null = null;\n\nexport function invokeComponentCallback(vm: VM, fn: () => any, fnCtx: any, args?: Array<any>): any {\n    const { context } = vm;\n    const ctx = currentContext;\n    establishContext(context);\n    let result, error;\n    try {\n        // TODO: membrane proxy for all args that are objects\n        result = fn.apply(fnCtx, args);\n    } catch (e) {\n        error = e;\n    }\n    establishContext(ctx);\n    if (error) {\n        throw error; // rethrowing the original error after restoring the context\n    }\n    return result;\n}\n\nexport function invokeComponentMethod(vm: VM, methodName: string, args?: Array<any>): any {\n    const { component } = vm;\n    return invokeComponentCallback(vm, component[methodName], component, args);\n}\n\nexport function invokeComponentConstructor(vm: VM, Ctor: Class<Component>): Component {\n    const { context } = vm;\n    const ctx = currentContext;\n    establishContext(context);\n    let component, error;\n    try {\n        component = new Ctor();\n    } catch (e) {\n        error = e;\n    }\n    establishContext(ctx);\n    if (error) {\n        throw error; // rethrowing the original error after restoring the context\n    }\n    return component;\n}\n\nexport function invokeComponentRenderMethod(vm: VM): Array<VNode> {\n    const { component, context } = vm;\n    const ctx = currentContext;\n    establishContext(context);\n    const isRenderingInception = isRendering;\n    const vmBeingRenderedInception = vmBeingRendered;\n    isRendering = true;\n    vmBeingRendered = vm;\n    let result, error;\n    try {\n        const html = component.render();\n        if (isFunction(html)) {\n            result = evaluateTemplate(vm, html);\n        } else if (isPromise(html)) {\n            result = deferredTemplate(vm, html);\n        } else if (!isUndefined(html)) {\n            assert.fail(`The template rendered by ${vm} must return an imported template tag (e.g.: \\`import html from \"./mytemplate.html\"\\`) or undefined, instead, it has returned ${html}.`);\n        }\n    } catch (e) {\n        error = e;\n    }\n    isRendering = isRenderingInception;\n    vmBeingRendered = vmBeingRenderedInception;\n    establishContext(ctx);\n    if (error) {\n        throw error; // rethrowing the original error after restoring the context\n    }\n    return result || [];\n}\n\nexport function invokeComponentAttributeChangedCallback(vm: VM, attrName: string, oldValue: any, newValue: any) {\n    const { component, context } = vm;\n    const { attributeChangedCallback } = component;\n    if (isUndefined(attributeChangedCallback)) {\n        return;\n    }\n    const ctx = currentContext;\n    establishContext(context);\n    let error;\n    try {\n        component.attributeChangedCallback(attrName, oldValue, newValue);\n    } catch (e) {\n        error = e;\n    }\n    establishContext(ctx);\n    if (error) {\n        throw error; // rethrowing the original error after restoring the context\n    }\n}\n","import assert from \"./assert\";\nimport {\n    invokeComponentConstructor,\n    invokeComponentRenderMethod,\n    isRendering,\n    vmBeingRendered,\n    invokeComponentAttributeChangedCallback,\n    invokeComponentMethod,\n    invokeComponentCallback,\n} from \"./invoker\";\nimport { notifyListeners } from \"./watcher\";\nimport { isArray, isUndefined, create, toString, ArrayPush, ArrayIndexOf, ArraySplice, isObject, defineProperties } from \"./language\";\nimport { addCallbackToNextTick, getAttrNameFromPropName, noop } from \"./utils\";\nimport { extractOwnFields, getPropertyProxy } from \"./properties\";\nimport { invokeServiceHook, Services } from \"./services\";\n\nexport let vmBeingConstructed: VM | null = null;\n\nexport function isBeingConstructed(vm: VM): boolean {\n    assert.vm(vm);\n    return vmBeingConstructed === vm;\n}\n\nexport function createComponent(vm: VM, Ctor: Class<Component>) {\n    assert.vm(vm);\n    // create the component instance\n    const vmBeingConstructedInception = vmBeingConstructed;\n    vmBeingConstructed = vm;\n    const component = invokeComponentConstructor(vm, Ctor);\n    vmBeingConstructed = vmBeingConstructedInception;\n    assert.block(function devModeCheck() {\n        extractOwnFields(component);\n    });\n    assert.isTrue(vm.component === component, `Invalid construction for ${vm}, maybe you are missing the call to super() on classes extending Element.`);\n}\n\nexport function linkComponent(vm: VM) {\n    assert.vm(vm);\n    const {\n        vnode: { elm },\n        component,\n        def: { methods: publicMethodsConfig, props: publicProps }\n    } = vm;\n    const descriptors: PropertyDescriptorMap = {};\n    // expose public methods as props on the Element\n    for (let key in publicMethodsConfig) {\n        const getter = function (component: Component, key: string): any {\n            return component[key];\n        }\n        descriptors[key] = {\n            get: getter.bind(undefined, component, key),\n        };\n    }\n    for (let key in publicProps) {\n        let {\n            getter,\n        } = publicProps[key];\n        if (isUndefined(getter)) {\n            // default getter\n            getter = (function runGetter(vm: VM, key: string): any {\n                return this[key];\n            }).bind(component, vm, key);\n        } else {\n            // original getter\n            getter = getter.bind(component);\n        }\n\n        const setter = (function runSetter(vm: VM, key: string, value: any): any {\n            if (vm.vnode.isRoot) {\n                // logic for setting new properties of the element directly from the DOM\n                // will only be allowed for root elements created via createElement()\n                // proxifying before storing it is a must for public props\n                value = isObject(value) ? getPropertyProxy(value) : value;\n                updateComponentProp(vm, key, value);\n            } else {\n                assert.logError(`Invalid attempt to set property ${key} from ${vm} to a new value. This property was decorated with @api, and can only be changed via the template.`);\n            }\n        }).bind(component, vm, key);\n\n        descriptors[key] = {\n            get: getter,\n            set: setter,\n        };\n    }\n    defineProperties(elm, descriptors);\n    // wiring service\n    const { def: { wire } } = vm;\n    if (wire) {\n        const { wiring } = Services;\n        if (wiring) {\n            invokeServiceHook(vm, wiring);\n            assert.block(function devModeCheck() {\n                // Mark instance properties for services special\n                extractOwnFields(component, true);\n            });\n\n        }\n    }\n}\n\nexport function clearListeners(vm: VM) {\n    assert.vm(vm);\n    const { deps } = vm;\n    const len = deps.length;\n    if (len) {\n        for (let i = 0; i < len; i += 1) {\n            const set = deps[i];\n            const pos = ArrayIndexOf.call(deps[i], vm);\n            assert.invariant(pos > -1, `when clearing up deps, the vm must be part of the collection.`);\n            ArraySplice.call(set, pos, 1);\n        }\n        deps.length = 0;\n    }\n}\n\nexport function updateComponentProp(vm: VM, propName: string, newValue: any) {\n    assert.vm(vm);\n    const { cmpProps, def: { props: publicProps, observedAttrs } } = vm;\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n    const propDef: PropDef = publicProps[propName];\n    if (isUndefined(propDef)) {\n        // TODO: this should never really happen because the compiler should always validate\n        console.warn(`Ignoring unknown public property ${propName} of ${vm}. This is likely a typo on the corresponding attribute \"${getAttrNameFromPropName(propName)}\".`);\n        return;\n    }\n    assert.isFalse(propDef.getter && !propDef.setter, `Invalid attempt to set a new value for property ${propName} of ${vm} that does not has a setter.`);\n    const { setter } = propDef;\n    if (setter) {\n        setter.call(vm.component, newValue);\n        return;\n    }\n    let oldValue = cmpProps[propName];\n    if (oldValue !== newValue) {\n        assert.block(function devModeCheck() {\n            if (isObject(newValue)) {\n                assert.invariant(getPropertyProxy(newValue) === newValue, `updateComponentProp() should always received proxified object values instead of ${newValue} in ${vm}.`);\n            }\n        });\n        cmpProps[propName] = newValue;\n        const attrName = getAttrNameFromPropName(propName);\n        if (attrName in observedAttrs) {\n            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);\n        }\n        notifyListeners(cmpProps, propName);\n    }\n}\n\nexport function resetComponentProp(vm: VM, propName: string) {\n    assert.vm(vm);\n    const { cmpProps, def: { props: publicPropsConfig, observedAttrs } } = vm;\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n    const propDef: PropDef = publicPropsConfig[propName];\n    if (isUndefined(propDef)) {\n        // not need to log the error here because we will do it on updateComponentProp()\n        return;\n    }\n    let newValue = undefined;\n    const { setter } = propDef;\n    if (setter) {\n        setter.call(vm.component, newValue);\n        return;\n    }\n    let oldValue = cmpProps[propName];\n    if (oldValue !== newValue) {\n        cmpProps[propName] = newValue;\n        const attrName = getAttrNameFromPropName(propName);\n        if (attrName in observedAttrs) {\n            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);\n        }\n        notifyListeners(cmpProps, propName);\n    }\n}\n\nexport function createComponentListener(): EventListener {\n    return function handler(event: Event) {\n        dispatchComponentEvent(handler.vm, event);\n    }\n}\n\nexport function addComponentEventListener(vm: VM, eventName: string, newHandler: EventListener) {\n    assert.vm(vm);\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding a new event listener for \"${eventName}\".`);\n    let { cmpEvents, cmpListener } = vm;\n    if (isUndefined(cmpEvents)) {\n        // this piece of code must be in sync with modules/component-events\n        vm.cmpEvents = cmpEvents = create(null);\n        vm.cmpListener = cmpListener = createComponentListener();\n        cmpListener.vm = vm;\n    }\n    if (isUndefined(cmpEvents[eventName])) {\n        cmpEvents[eventName] = [];\n        // this is not only an optimization, it is also needed to avoid adding the same\n        // listener twice when the initial diffing algo kicks in without an old vm to track\n        // what was already added to the DOM.\n        if (!vm.isDirty) {\n            // if the element is already in the DOM and rendered, we intentionally make a sync mutation\n            // here and also keep track of the mutation for a possible rehydration later on without having\n            // to rehydrate just now.\n            const { vnode: { elm } } = vm;\n            elm.addEventListener(eventName, cmpListener, false);\n        }\n    }\n    assert.block(function devModeCheck() {\n        if (cmpEvents[eventName] && ArrayIndexOf.call(cmpEvents[eventName], newHandler) !== -1) {\n            assert.logWarning(`${vm} has duplicate listeners for event \"${eventName}\". Instead add the event listener in the connectedCallback() hook.`);\n        }\n    });\n    ArrayPush.call(cmpEvents[eventName], newHandler);\n}\n\nexport function removeComponentEventListener(vm: VM, eventName: string, oldHandler: EventListener) {\n    assert.vm(vm);\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by removing an event listener for \"${eventName}\".`);\n    const { cmpEvents } = vm;\n    if (cmpEvents) {\n        const handlers = cmpEvents[eventName];\n        const pos = handlers && ArrayIndexOf.call(handlers, oldHandler);\n        if (handlers && pos > -1) {\n            ArraySplice.call(cmpEvents[eventName], pos, 1);\n            return;\n        }\n    }\n    assert.block(function devModeCheck() {\n        assert.logWarning(`Did not find event listener ${oldHandler} for event \"${eventName}\" on ${vm}. Instead only remove an event listener once.`);\n    });\n}\n\nexport function dispatchComponentEvent(vm: VM, event: Event): boolean {\n    assert.vm(vm);\n    assert.invariant(event instanceof Event, `dispatchComponentEvent() must receive an event instead of ${event}`);\n    const { cmpEvents, component } = vm;\n    const { type } = event;\n    assert.invariant(cmpEvents && cmpEvents[type] && cmpEvents[type].length, `dispatchComponentEvent() should only be invoked if there is at least one listener in queue for ${type} on ${vm}.`);\n    const handlers = cmpEvents[type];\n    let uninterrupted = true;\n    const { stopImmediatePropagation } = event;\n    event.stopImmediatePropagation = function() {\n        uninterrupted = false;\n        stopImmediatePropagation.call(this);\n    }\n    for (let i = 0, len = handlers.length; uninterrupted && i < len; i += 1) {\n        // TODO: only if the event is `composed` it can be dispatched\n        invokeComponentCallback(vm, handlers[i], component, [event]);\n    }\n    // restoring original methods\n    event.stopImmediatePropagation = stopImmediatePropagation;\n}\n\nexport function addComponentSlot(vm: VM, slotName: string, newValue: Array<VNode>) {\n    assert.vm(vm);\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of slot ${slotName} in ${vm}`);\n    assert.isTrue(isArray(newValue) && newValue.length > 0, `Slots can only be set to a non-empty array, instead received ${toString(newValue)} for slot ${slotName} in ${vm}.`)\n    let { cmpSlots } = vm;\n    let oldValue = cmpSlots && cmpSlots[slotName];\n    // TODO: hot-slots names are those slots used during the last rendering cycle, and only if\n    // one of those is changed, the vm should be marked as dirty.\n\n    // TODO: Issue #133\n    if (!isArray(newValue)) {\n        newValue = undefined;\n    }\n    if (oldValue !== newValue) {\n        if (isUndefined(cmpSlots)) {\n            vm.cmpSlots = cmpSlots = create(null);\n        }\n        cmpSlots[slotName] = newValue;\n        console.log(`Marking ${vm} as dirty: a new value for slot \"${slotName}\" was added.`);\n        if (!vm.isDirty) {\n            markComponentAsDirty(vm);\n        }\n    }\n}\n\nexport function removeComponentSlot(vm: VM, slotName: string) {\n    assert.vm(vm);\n    assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of slot ${slotName} in ${vm}`);\n    // TODO: hot-slots names are those slots used during the last rendering cycle, and only if\n    // one of those is changed, the vm should be marked as dirty.\n    const { cmpSlots } = vm;\n    if (cmpSlots && cmpSlots[slotName]) {\n        cmpSlots[slotName] = undefined; // delete will de-opt the cmpSlots, better to set it to undefined\n        console.log(`Marking ${vm} as dirty: the value of slot \"${slotName}\" was removed.`);\n        if (!vm.isDirty) {\n            markComponentAsDirty(vm);\n        }\n    }\n}\n\nexport function renderComponent(vm: VM) {\n    assert.vm(vm);\n    assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n    console.log(`${vm} is being updated.`);\n    clearListeners(vm);\n    const vnodes = invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    vm.fragment = vnodes;\n    assert.invariant(isArray(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n    const { component: { renderedCallback } } = vm;\n    if (renderedCallback && renderedCallback !== noop) {\n        addCallbackToNextTick((): void => invokeComponentMethod(vm, 'renderedCallback'));\n    }\n    const { rehydrated } = Services;\n    if (rehydrated) {\n        addCallbackToNextTick((): void => invokeServiceHook(vm, rehydrated));\n    }\n}\n\nexport function markComponentAsDirty(vm: VM) {\n    assert.vm(vm);\n    assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the componet is already dirty.`);\n    assert.isFalse(isRendering, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n    vm.isDirty = true;\n}\n","const isCompatMode = typeof Proxy === 'undefined';\n\nexport default function compat(fn: () => void) {\n    if (isCompatMode) {\n        fn();\n    }\n}\n","import assert from \"./assert\";\nimport { ArrayMap, isArray } from \"./language\";\nimport compat from \"./compat\";\n\n/*eslint-disable*/\nexport type ReplicableFunction = (...args: Array<any>) => any;\nexport type Replicable = Object | ReplicableFunction;\n\nexport type ReplicaFunction = (...args: Array<any>) => Replica | String | Number | Boolean | null | undefined;\nexport type Replica = Object | ReplicaFunction;\n\nexport interface MembraneHandler {\n    get(target: Replicable, key: string | Symbol): any;\n    set(target: Replicable, key: string | Symbol, newValue: any): boolean;\n    deleteProperty(target: Replicable, key: string | Symbol): boolean;\n    apply(targetFn: ReplicableFunction, thisArg: any, argumentsList: Array<any>): any;\n    construct(targetFn: ReplicableFunction, argumentsList: Array<any>, newTarget: any): any;\n}\n/*eslint-enable*/\n\nconst TargetSlot = Symbol();\nconst MembraneSlot = Symbol();\n\nfunction isReplicable(value: any): boolean {\n    const type = typeof value;\n    return value && (type === 'object' || type === 'function');\n}\n\nexport function getReplica(membrane: Membrane, value: Replicable | any): Replica | any {\n    if (value === null || !isReplicable(value)) {\n        return value;\n    }\n    assert.isTrue(membrane instanceof Membrane, `getReplica() first argument must be a membrane.`);\n    let { cells, cache } = membrane;\n    if (cache.has(value)) {\n        return value;\n    }\n    const r = cells.get(value);\n    if (r) {\n        return r;\n    }\n    const replica: Replica = new Proxy(value, (membrane as ProxyHandler<Replicable>)); // eslint-disable-line no-undef\n    cells.set(value, replica);\n    cache.add(replica);\n    return replica;\n}\n\nexport class Membrane {\n    handler: MembraneHandler; // eslint-disable-line no-undef\n    cells: WeakMap<Replicable, Replica>; // eslint-disable-line no-undef\n    cache: WeakSet<Replica>; // eslint-disable-line no-undef\n    constructor(handler: MembraneHandler) {\n        this.handler = handler;\n        this.cells = new WeakMap();\n        this.cache = new WeakSet();\n    }\n    get(target: Replicable, key: string | Symbol): any {\n        if (key === TargetSlot) {\n            return target;\n        } else if (key === MembraneSlot) {\n            return this;\n        }\n        const value = this.handler.get(target, key);\n        return getReplica(this, value);\n    }\n    set(target: Replicable, key: string | Symbol, newValue: any): boolean {\n        return this.handler.set(target, key, newValue);\n    }\n    deleteProperty(target: Replicable, key: string | Symbol): boolean {\n        if (key === TargetSlot) {\n            return false;\n        }\n        return this.handler.deleteProperty(target, key);\n    }\n    apply(target: ReplicableFunction, thisArg: any, argumentsList: Array<any>): any {\n        thisArg = unwrap(thisArg);\n        argumentsList = unwrap(argumentsList);\n        if (isArray(argumentsList)) {\n            argumentsList = ArrayMap.call(argumentsList, unwrap);\n        }\n        const value = this.handler.apply(target, thisArg, argumentsList);\n        return getReplica(this, value);\n    }\n    construct(target: ReplicableFunction, argumentsList: Array<any>, newTarget: any): any {\n        argumentsList = unwrap(argumentsList);\n        if (isArray(argumentsList)) {\n            argumentsList = ArrayMap.call(argumentsList, unwrap);\n        }\n        const value = this.handler.construct(target, argumentsList, newTarget);\n        return getReplica(this, value);\n    }\n}\n\nexport function unwrap(replicaOrAny: Replica | any): Replicable | any {\n    return (replicaOrAny && replicaOrAny[TargetSlot]) || replicaOrAny;\n}\n\nexport function setKey(replicaOrAny: Replica | any, key: string | Symbol, newValue: any): any {\n    let shouldReturn = false;\n    compat(() => {\n        shouldReturn = true;\n        const target = unwrap(replicaOrAny);\n        if (target === replicaOrAny) {\n            // non-proxified assignment\n            target[key] = newValue;\n        } else {\n            replicaOrAny[MembraneSlot].set(target, key, newValue);\n        }\n    });\n    return shouldReturn ? newValue : undefined;\n}\n\nexport function deleteKey(replicaOrAny: Replica | any, key: string | Symbol) {\n    compat(() => {\n        const target = unwrap(replicaOrAny);\n        if (target === replicaOrAny) {\n            // non-profixied delete\n            delete target[key];\n        } else {\n            replicaOrAny[MembraneSlot].deleteProperty(target, key);\n        }\n    });\n}\n","import assert from \"./assert\";\nimport { OwnerKey } from \"./vm\";\nimport { Services } from \"./services\";\nimport { getReplica, Membrane } from \"./membrane\";\n\n/* eslint-disable */\nimport { Replicable, ReplicableFunction, MembraneHandler } from \"./membrane\";\n/* eslint-enable */\n\nfunction piercingHook(vm: VM, target: Replicable, key: string | Symbol, value: any): any {\n    assert.vm(vm);\n    const { piercing } = Services;\n    if (piercing) {\n        const { component, vnode: { data }, def, context } = vm;\n        let result = value;\n        let next = true;\n        const callback = (newValue?: any) => {\n            next = false;\n            result = newValue;\n        };\n        for (let i = 0, len = piercing.length; next && i < len; ++i) {\n            piercing[i].call(undefined, component, data, def, context, target, key, value, callback);\n        }\n        return result;\n    }\n}\n\nexport class PiercingMembraneHandler implements MembraneHandler {\n    vm: VM; // eslint-disable-line no-undef\n    constructor(vm: VM) {\n        assert.vm(vm);\n        this.vm = vm;\n    }\n    get(target: Replicable, key: string | Symbol): any {\n        if (key === OwnerKey) {\n            return undefined;\n        }\n        let value = target[key];\n        return piercingHook(this.vm, target, key, value);\n    }\n    set(target: Replicable, key: string, newValue: any): boolean {\n        target[key] = newValue;\n        return true;\n    }\n    deleteProperty(target: Replicable, key: string | Symbol): boolean {\n        delete target[key];\n        return true;\n    }\n    apply(targetFn: ReplicableFunction, thisArg: any, argumentsList: Array<any>): any {\n        return targetFn.apply(thisArg, argumentsList);\n    }\n    construct(targetFn: ReplicableFunction, argumentsList: Array<any>, newTarget: any): any {\n        assert.isTrue(newTarget, `construct handler expects a 3rd argument with a newly created object that will be ignored in favor of the wrapped constructor.`);\n        return new targetFn(...argumentsList);\n    }\n}\n\nexport function pierce(vm: VM, value: Replicable | any): any {\n    assert.vm(vm);\n    let { membrane } = vm;\n    if (!membrane) {\n        const handler = new PiercingMembraneHandler(vm);\n        membrane = new Membrane(handler);\n        vm.membrane = membrane;\n    }\n    return getReplica(membrane, value);\n}\n","import assert from \"./assert\";\nimport { ViewModelReflection } from \"./html-element\";\nimport { ArrayFilter, defineProperty } from \"./language\";\nimport { isBeingConstructed } from \"./component\";\nimport { OwnerKey, isNodeOwnedByVM } from \"./vm\";\nimport { register } from \"./services\";\nimport { pierce } from \"./piercing\";\n\nconst { querySelector, querySelectorAll } = Element.prototype;\n\nfunction getLinkedElement(root: Root): HTMLElement {\n    return root[ViewModelReflection].vnode.elm;\n}\n\nexport function shadowRootQuerySelector (shadowRoot: ShadowRoot, selector: string): MembraneObject | null {\n    const vm = shadowRoot[ViewModelReflection];\n    assert.isFalse(isBeingConstructed(vm), `this.root.querySelector() cannot be called during the construction of the custom element for ${this} because no content has been rendered yet.`);\n    const elm = getLinkedElement(shadowRoot);\n    return pierce(vm, elm).querySelector(selector);\n}\n\nexport function shadowRootQuerySelectorAll (shadowRoot: ShadowRoot, selector: string): MembraneObject {\n    const vm = shadowRoot[ViewModelReflection];\n    assert.isFalse(isBeingConstructed(vm), `this.root.querySelectorAll() cannot be called during the construction of the custom element for ${this} because no content has been rendered yet.`);\n    const elm = getLinkedElement(shadowRoot);\n    return pierce(vm, elm).querySelectorAll(selector);\n}\n\nexport function Root(vm: VM): ShadowRoot {\n    assert.vm(vm);\n    defineProperty(this, ViewModelReflection, {\n        value: vm,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n    });\n}\n\nRoot.prototype = {\n    get mode(): string {\n        return 'closed';\n    },\n    get host(): Component {\n        return this[ViewModelReflection].component;\n    },\n    querySelector(selector: string): MembraneObject | null {\n        const node = shadowRootQuerySelector(this, selector);\n        assert.block(() => {\n            const vm = this[ViewModelReflection];\n            if (!node && vm.component.querySelector(selector)) {\n                assert.logWarning(`this.root.querySelector() can only return elements from the template declaration of ${vm.component}. It seems that you are looking for elements that were passed via slots, in which case you should use this.querySelector() instead.`);\n            }\n        });\n        return node;\n    },\n    querySelectorAll(selector: string): MembraneObject {\n        const nodeList = shadowRootQuerySelectorAll(this, selector);\n        assert.block(() => {\n            const vm = this[ViewModelReflection];\n            if (nodeList.length === 0 && vm.component.querySelectorAll(selector).length) {\n                assert.logWarning(`this.root.querySelectorAll() can only return elements from template declaration of ${vm.component}. It seems that you are looking for elements that were passed via slots, in which case you should use this.querySelectorAll() instead.`);\n            }\n        });\n        return nodeList;\n    },\n    toString(): string {\n        const vm = this[ViewModelReflection];\n        return `Current ShadowRoot for ${vm.component}`;\n    }\n};\n\nfunction getFirstMatch(vm: VM, elm: Element, selector: string): Node | null {\n    const nodeList = querySelectorAll.call(elm, selector);\n    // search for all, and find the first node that is owned by the VM in question.\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        if (isNodeOwnedByVM(vm, nodeList[i])) {\n            return pierce(vm, nodeList[i]);\n        }\n    }\n    return null;\n}\n\nfunction getAllMatches(vm: VM, elm: Element, selector: string): NodeList {\n    const nodeList = querySelectorAll.call(elm, selector);\n    const filteredNodes = ArrayFilter.call(nodeList, (node: Node): boolean => isNodeOwnedByVM(vm, node));\n    return pierce(vm , filteredNodes);\n}\n\nfunction isParentNodeKeyword(key: string): boolean {\n    return (key === 'parentNode' || key === 'parentElement');\n}\n\n// Registering a service to enforce the shadowDOM semantics via the Raptor membrane implementation\nregister({\n    piercing(component: Component, data: VNodeData, def: ComponentDef, context: HashTable<any>, target: Replicable, key: Symbol | string, value: any, callback: (value: any) => void) {\n        if (value === querySelector) {\n            // TODO: it is possible that they invoke the querySelector() function via call or apply to set a new context, what should\n            // we do in that case? Right now this is essentially a bound function, but the original is not.\n            return callback((selector: string): Node | null => getFirstMatch(component[ViewModelReflection], target, selector));\n        }\n        if (value === querySelectorAll) {\n            // TODO: it is possible that they invoke the querySelectorAll() function via call or apply to set a new context, what should\n            // we do in that case? Right now this is essentially a bound function, but the original is not.\n            return callback((selector: string): Node | null => getAllMatches(component[ViewModelReflection], target, selector));\n        }\n        if (value && value.splitText && isParentNodeKeyword(key)) {\n            if (value === component[ViewModelReflection].vnode.elm) {\n                // walking up via parent chain might end up in the shadow root element\n                return callback(component.root);\n            } else if (target[OwnerKey] !== value[OwnerKey]) {\n                // cutting out access to something outside of the shadow of the current target by calling back with undefined\n                return callback();\n            }\n        }\n    }\n});\n","import assert from \"./assert\";\nimport { ClassList } from \"./class-list\";\nimport { Root, shadowRootQuerySelector, shadowRootQuerySelectorAll } from \"./root\";\nimport { vmBeingConstructed, isBeingConstructed, addComponentEventListener, removeComponentEventListener } from \"./component\";\nimport { ArrayFilter, isArray, freeze, seal, defineProperty, getOwnPropertyNames, isUndefined, isObject, create } from \"./language\";\nimport { getPropertyProxy } from \"./properties\";\nimport { GlobalHTMLProperties } from \"./dom\";\nimport { getPropNameFromAttrName, noop, toAttributeValue } from \"./utils\";\nimport { isRendering, vmBeingRendered } from \"./invoker\";\nimport { subscribeToSetHook, notifyListeners } from \"./watcher\";\nimport { wasNodePassedIntoVM } from \"./vm\";\nimport { pierce } from \"./piercing\";\n\nexport const ViewModelReflection = Symbol('internal');\n\nfunction getLinkedElement(cmp: ComponentElement): HTMLElement {\n    return cmp[ViewModelReflection].vnode.elm;\n}\n\nfunction querySelectorAllFromComponent(cmp: ComponentElement, selectors: string): NodeList {\n    const elm = getLinkedElement(cmp);\n    return elm.querySelectorAll(selectors);\n}\n\nexport function createPublicPropertyDescriptor(propName: string, originalPropertyDescriptor?: PropertyDescriptor): PropertyDescriptor {\n    function getter(): any {\n        const vm: VM = this[ViewModelReflection];\n        assert.vm(vm);\n        const { propName, origGetter } = getter;\n        if (isBeingConstructed(vm)) {\n            assert.logError(`${vm} constructor should not read the value of property \"${propName}\". The owner component has not yet set the value. Instead use the constructor to set default values for properties.`);\n            return;\n        }\n        if (origGetter) {\n            return origGetter.call(vm.component);\n        }\n        const { cmpProps } = vm;\n        if (isRendering) {\n            // this is needed because the proxy used by template is not sufficient\n            // for public props accessed from within a getter in the component.\n            subscribeToSetHook(vmBeingRendered, cmpProps, propName);\n        }\n        return cmpProps[propName];\n    }\n    getter.propName = propName;\n    getter.origGetter = originalPropertyDescriptor && originalPropertyDescriptor.get;\n\n    function setter(value: any) {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        const { propName, origSetter } = setter;\n        if (!isBeingConstructed(vm)) {\n            assert.logError(`${vm} can only set a new value for property \"${propName}\" during construction.`);\n            return;\n        }\n        if (origSetter) {\n            origSetter.call(vm.component, value);\n            return;\n        }\n        const { cmpProps } = vm;\n        // proxifying before storing it is a must for public props\n        cmpProps[propName] = isObject(value) ? getPropertyProxy(value) : value;\n    }\n    setter.propName = propName;\n    setter.origSetter = originalPropertyDescriptor && originalPropertyDescriptor.set;\n\n    const descriptor: PropertyDescriptor = {\n        get: getter,\n        set: setter,\n        enumerable: true,\n        configurable: true,\n    };\n    return descriptor;\n}\n\n\nexport function createWiredPropertyDescriptor(propName: string): PropertyDescriptor {\n    function getter(): HashTable<any> {\n        const vm: VM = this[ViewModelReflection];\n        assert.vm(vm);\n        let { cmpWired } = vm;\n        if (isUndefined(cmpWired)) {\n            cmpWired = vm.cmpWired = getPropertyProxy(create(null)); // lazy creation of the value\n        }\n        let value = cmpWired[propName];\n        if (isRendering) {\n            // this is needed because the proxy used by template is not sufficient\n            // for public props accessed from within a getter in the component.\n            subscribeToSetHook(vmBeingRendered, cmpWired, propName);\n        }\n        return value;\n    }\n    function setter(value: any) {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        if (!value || !isObject(value)) {\n            assert.logError(`${vm} failed to set new value into property \"${propName}\". It can only be set to an object.`);\n            return;\n        }\n        let { cmpWired } = vm;\n        if (isUndefined(cmpWired)) {\n            cmpWired = vm.cmpWired = getPropertyProxy(create(null)); // lazy creation of the value\n        }\n        cmpWired[propName] = isObject(value) ? getPropertyProxy(value) : value;\n        notifyListeners(cmpWired, propName);\n    }\n    const descriptor: PropertyDescriptor = {\n        get: getter,\n        set: setter,\n        enumerable: true,\n        configurable: true,\n    };\n    return descriptor;\n}\n\n// This should be as performant as possible, while any initialization should be done lazily\nfunction ComponentElement(): ComponentElement {\n    assert.vm(vmBeingConstructed, `Invalid construction.`);\n    assert.vnode(vmBeingConstructed.vnode, `Invalid construction.`);\n    const vnode = vmBeingConstructed.vnode;\n    assert.invariant(vnode.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${vnode}.`);\n    vmBeingConstructed.component = this;\n    this[ViewModelReflection] = vmBeingConstructed;\n}\n\nComponentElement.prototype = {\n    // Raptor.Element APIs\n    renderedCallback: noop,\n    render: noop,\n\n    // Web Component - The Good Parts\n    connectedCallback: noop,\n    disconnectedCallback: noop,\n\n    // HTML Element - The Good Parts\n    dispatchEvent(event: Event): boolean {\n        const elm = getLinkedElement(this);\n        assert.isFalse(isBeingConstructed(this[ViewModelReflection]), `this.dispatchEvent() should not be called during the construction of the custom element for ${this} because no one is listening for the event ${event} just yet.`);\n        // custom elements will rely on the DOM dispatchEvent mechanism\n        return elm.dispatchEvent(event);\n    },\n    addEventListener(type: string, listener: EventListener) {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        assert.block(function devModeCheck() {\n            if (arguments.length > 2) {\n                // TODO: can we synthetically implement `passive` and `once`? Capture is probably ok not supporting it.\n                assert.logWarning(`this.addEventListener() on ${vm} does not support more than 2 arguments. Options to make the listener passive, once or capture are not allowed at the top level of the component's fragment.`);\n            }\n        });\n        addComponentEventListener(vm, type, listener);\n    },\n    removeEventListener(type: string, listener: EventListener) {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        assert.block(function devModeCheck() {\n            if (arguments.length > 2) {\n                assert.logWarning(`this.removeEventListener() on ${vm} does not support more than 2 arguments. Options to make the listener passive or capture are not allowed at the top level of the component's fragment.`);\n            }\n        });\n        removeComponentEventListener(vm, type, listener);\n    },\n    getAttribute(attrName: string): string | null {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        const { vnode: { data: { attrs } } } = vm;\n        if (!attrName) {\n            if (arguments.length === 0) {\n                throw new TypeError(`Failed to execute \\`getAttribute\\` on ${vm}: 1 argument is required, got 0.`);\n            }\n            return null;\n        }\n        // logging errors for experimentals and special attributes\n        assert.block(function devModeCheck() {\n            const propName = getPropNameFromAttrName(attrName);\n            const { def: { props: publicPropsConfig } } = vm;\n            if (publicPropsConfig[propName]) {\n                throw new ReferenceError(`Attribute \"${attrName}\" corresponds to public property ${propName} from ${vm}. Instead use \\`this.${propName}\\`. Only use \\`getAttribute()\\` to access global HTML attributes.`);\n            } else if (GlobalHTMLProperties[propName] && GlobalHTMLProperties[propName].attribute) {\n                const { error, experimental } = GlobalHTMLProperties[propName];\n                if (error) {\n                    console.error(error);\n                } else if (experimental) {\n                    console.error(`Attribute \\`${attrName}\\` is an experimental attribute that is not standardized or supported by all browsers. Property \"${propName}\" and attribute \"${attrName}\" are ignored.`);\n                }\n            }\n        });\n        // normalizing attrs from compiler into HTML global attributes\n        let raw = attrs && attrName in attrs ? attrs[attrName] : null;\n        return toAttributeValue(raw);\n    },\n    getBoundingClientRect(): DOMRect {\n        const elm = getLinkedElement(this);\n        assert.isFalse(isBeingConstructed(this[ViewModelReflection]), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${this} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n        return elm.getBoundingClientRect();\n    },\n    querySelector(selectors: string): Node | null {\n        const vm = this[ViewModelReflection];\n        assert.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${this} because no children has been added to this element yet.`);\n        const nodeList = querySelectorAllFromComponent(this, selectors);\n        for (let i = 0, len = nodeList.length; i < len; i += 1) {\n            if (wasNodePassedIntoVM(vm, nodeList[i])) {\n                // TODO: locker service might need to return a membrane proxy\n                return pierce(vm, nodeList[i]);\n            }\n        }\n        assert.block(() => {\n            if (shadowRootQuerySelector(this.root, selectors)) {\n                assert.logWarning(`this.querySelector() can only return elements that were passed into ${vm.component} via slots. It seems that you are looking for elements from your template declaration, in which case you should use this.root.querySelector() instead.`);\n            }\n        });\n\n        return null;\n    },\n    querySelectorAll(selectors: string): NodeList {\n        const vm = this[ViewModelReflection];\n        assert.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${this} because no children has been added to this element yet.`);\n        const nodeList = querySelectorAllFromComponent(this, selectors);\n        // TODO: locker service might need to do something here\n        const filteredNodes = ArrayFilter.call(nodeList, (node: Node): boolean => wasNodePassedIntoVM(vm, node));\n        assert.block(() => {\n            if (filteredNodes.length === 0 && shadowRootQuerySelectorAll(this.root, selectors).length) {\n                assert.logWarning(`this.querySelectorAll() can only return elements that were passed into ${vm.component} via slots. It seems that you are looking for elements from your template declaration, in which case you should use this.root.querySelectorAll() instead.`);\n            }\n        });\n        return pierce(vm, filteredNodes);\n    },\n    get tagName(): string {\n        const elm = getLinkedElement(this);\n        return elm.tagName + ''; // avoiding side-channeling\n    },\n    get classList(): DOMTokenList {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        let { classListObj } = vm;\n        // lazy creation of the ClassList Object the first time it is accessed.\n        if (isUndefined(classListObj)) {\n            vm.cmpClasses = {};\n            classListObj = new ClassList(vm);\n            vm.classListObj = classListObj;\n        }\n        return classListObj;\n    },\n    get root(): ShadowRoot {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        let { cmpRoot } = vm;\n        // lazy creation of the ShadowRoot Object the first time it is accessed.\n        if (isUndefined(cmpRoot)) {\n            cmpRoot = new Root(vm);\n            vm.cmpRoot = cmpRoot;\n        }\n        return cmpRoot;\n    },\n    get state(): HashTable<any> {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        let { cmpState } = vm;\n        if (isUndefined(cmpState)) {\n            cmpState = vm.cmpState = getPropertyProxy(create(null)); // lazy creation of the cmpState\n        }\n        return cmpState;\n    },\n    set state(newState: HashTable<any>) {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        if (!newState || !isObject(newState) || isArray(newState)) {\n            assert.logError(`${vm} failed to set new state to ${newState}. \\`this.state\\` can only be set to an object.`);\n            return;\n        }\n        let { cmpState } = vm;\n        if (isUndefined(cmpState)) {\n            cmpState = vm.cmpState = getPropertyProxy(create(null)); // lazy creation of the cmpState\n        }\n        if (cmpState !== newState) {\n            for (let key in cmpState) {\n                if (!(key in newState)) {\n                    cmpState[key] = undefined; // prefer setting to undefined over deleting for perf reasons\n                }\n            }\n            for (let key in newState) {\n                cmpState[key] = newState[key];\n            }\n        }\n    },\n    toString(): string {\n        const vm = this[ViewModelReflection];\n        assert.vm(vm);\n        const { vnode: { sel, data: { attrs } } } = vm;\n        const is = attrs && attrs.is;\n        return `<${sel}${ is ? ' is=\"${is}' : '' }>`;\n    },\n}\n\n// Global HTML Attributes\nassert.block(function devModeCheck() {\n\n    getOwnPropertyNames(GlobalHTMLProperties).forEach((propName: string) => {\n        if (propName in ComponentElement.prototype) {\n            return; // no need to redefine something that we are already exposing\n        }\n        defineProperty(ComponentElement.prototype, propName, {\n            get: function () {\n                const vm = this[ViewModelReflection];\n                assert.vm(vm);\n                const { error, attribute, readOnly, experimental } = GlobalHTMLProperties[propName];\n                const msg = [];\n                msg.push(`Accessing the global HTML property \"${propName}\" in ${vm} is disabled.`);\n                if (error) {\n                    msg.push(error);\n                } else {\n                    if (experimental) {\n                        msg.push(`This is an experimental property that is not standardized or supported by all browsers. Property \"${propName}\" and attribute \"${attribute}\" are ignored.`);\n                    }\n                    if (readOnly) {\n                        // TODO - need to improve this message\n                        msg.push(`Property is read-only.`);\n                    }\n                    if (attribute) {\n                        msg.push(`\"Instead access it via the reflective attribute \"${attribute}\" with one of these techniques:`);\n                        msg.push(`  * Use \\`this.getAttribute(\"${attribute}\")\\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);\n                        msg.push(`  * Declare \\`static observedAttributes = [\"${attribute}\"]\\` and use \\`attributeChangedCallback(attrName, oldValue, newValue)\\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);\n                    }\n                }\n                console.log(msg.join('\\n'));\n                return; // explicit undefined\n            },\n            enumerable: false,\n        })\n    });\n\n});\n\nfreeze(ComponentElement);\nseal(ComponentElement.prototype);\n\nexport { ComponentElement as Element };\n","/**\n * This module is responsible for producing the ComponentDef object that is always\n * accessible via `vm.def`. This is lazily created during the creation of the first\n * instance of a component class, and shared across all instances.\n *\n * This structure can be used to synthetically create proxies, and understand the\n * shape of a component. It is also used internally to apply extra optimizations.\n */\n\nimport assert from \"./assert\";\nimport {\n    assign,\n    freeze,\n    create,\n    ArrayIndexOf,\n    toString,\n    ArrayPush,\n    defineProperty,\n    getOwnPropertyDescriptor,\n    getOwnPropertyNames,\n    getPrototypeOf,\n    isString,\n    isFunction,\n    isUndefined,\n    isObject,\n} from \"./language\";\nimport { GlobalHTMLProperties } from \"./dom\";\nimport { Element, createPublicPropertyDescriptor, createWiredPropertyDescriptor } from \"./html-element\";\nimport { EmptyObject } from \"./utils\";\n\nconst CtorToDefMap: Map<any, ComponentDef> = new WeakMap();\n\nconst COMPUTED_GETTER_MASK = 1;\nconst COMPUTED_SETTER_MASK = 2;\n\nfunction isElementComponent(Ctor: any, protoSet?: Array<any>): boolean {\n    protoSet = protoSet || [];\n    if (!Ctor || ArrayIndexOf.call(protoSet, Ctor) >= 0) {\n        return false; // null, undefined, or circular prototype definition\n    }\n    const proto = getPrototypeOf(Ctor);\n    if (proto === Element) {\n        return true;\n    }\n    getComponentDef(proto); // ensuring that the prototype chain is already expanded\n    ArrayPush.call(protoSet, Ctor);\n    return isElementComponent(proto, protoSet);\n}\n\nfunction createComponentDef(Ctor: Class<Component>): ComponentDef {\n    assert.isTrue(isElementComponent(Ctor), `${Ctor} is not a valid component, or does not extends Element from \"engine\". You probably forgot to add the extend clause on the class declaration.`);\n    const name: string = Ctor.name;\n    assert.isTrue(name && isString(name), `${toString(Ctor)} should have a \"name\" property with string value, but found ${name}.`);\n    assert.isTrue(Ctor.constructor, `Missing ${name}.constructor, ${name} should have a \"constructor\" property.`);\n    let props = getPublicPropertiesHash(Ctor);\n    let methods = getPublicMethodsHash(Ctor);\n    let observedAttrs = getObservedAttributesHash(Ctor);\n    let wire = getWireHash(Ctor);\n\n    const proto = Ctor.prototype;\n    for (let propName in props) {\n        const propDef = props[propName];\n        // initializing getters and setters for each public prop on the target prototype\n        const descriptor = getOwnPropertyDescriptor(proto, propName);\n        const isComputed = descriptor && (isFunction(descriptor.get) || isFunction(descriptor.set));\n        assert.invariant(!descriptor || isComputed, `Invalid ${name}.prototype.${propName} definition, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`);\n        const { config } = propDef;\n        if (COMPUTED_GETTER_MASK & config) {\n            assert.isTrue(isObject(descriptor) && isFunction(descriptor.get), `Missing getter for property ${propName} decorated with @api in ${name}`);\n            propDef.getter = descriptor.get;\n        }\n        if (COMPUTED_SETTER_MASK & config) {\n            assert.isTrue(isObject(descriptor) && isFunction(descriptor.set), `Missing setter for property ${propName} decorated with @api in ${name}`);\n            propDef.setter = descriptor.set;\n        }\n        defineProperty(proto, propName, createPublicPropertyDescriptor(propName, descriptor));\n    }\n\n    if (wire) {\n        for (let propName in wire) {\n            const descriptor = getOwnPropertyDescriptor(proto, propName);\n            // for decorated methods we need to do nothing\n            if (isUndefined(wire[propName].method)) {\n                // initializing getters and setters for each public prop on the target prototype\n                const isComputed = descriptor && (isFunction(descriptor.get) || isFunction(descriptor.set));\n                assert.invariant(!descriptor || isComputed, `Invalid ${name}.prototype.${propName} definition, it cannot be a prototype definition if it is a property decorated with the @wire decorator.`);\n                defineProperty(proto, propName, createWiredPropertyDescriptor(propName));\n            }\n        }\n    }\n\n    const superProto = getPrototypeOf(Ctor);\n    if (superProto !== Element) {\n        const superDef = getComponentDef(superProto);\n        props = assign(create(null), superDef.props, props);\n        methods = assign(create(null), superDef.methods, methods);\n        wire = (superDef.wire || wire) ? assign(create(null), superDef.wire, wire) : undefined;\n    }\n\n    const def: ComponentDef = {\n        name,\n        wire,\n        props,\n        methods,\n        observedAttrs,\n    };\n    assert.block(function devModeCheck() {\n        freeze(Ctor.prototype);\n        freeze(wire);\n        freeze(props);\n        freeze(methods);\n        freeze(observedAttrs);\n        for (let key in def) {\n            defineProperty(def, key, {\n                configurable: false,\n                writable: false,\n            });\n        }\n    });\n    return def;\n}\n\nfunction getWireHash(target: Object): HashTable<WireDef> | undefined {\n    const wire: HashTable = target.wire;\n    if (!wire || !getOwnPropertyNames(wire).length) {\n        return;\n    }\n\n    assert.block(function devModeCheck() {\n        // TODO: check that anything in `wire` is correctly defined in the prototype\n    });\n    return assign(create(null), wire);\n}\n\nfunction getPublicPropertiesHash(target: Object): HashTable<PropDef> {\n    const props: HashTable = target.publicProps;\n    if (!props || !getOwnPropertyNames(props).length) {\n        return EmptyObject;\n    }\n    return getOwnPropertyNames(props).reduce((propsHash: HashTable<PropDef>, propName: string): HashTable<PropDef> => {\n        assert.block(function devModeCheck() {\n            if (GlobalHTMLProperties[propName] && GlobalHTMLProperties[propName].attribute) {\n                const { error, attribute, experimental } = GlobalHTMLProperties[propName];\n                const msg = [];\n                if (error) {\n                    msg.push(error);\n                } else if (experimental) {\n                    msg.push(`\"${propName}\" is an experimental property that is not standardized or supported by all browsers. Property \"${propName}\" and attribute \"${attribute}\" are ignored.`);\n                } else {\n                    msg.push(`\"${propName}\" is a global HTML property. Instead access it via the reflective attribute \"${attribute}\" with one of these techniques:`);\n                    msg.push(`  * Use \\`this.getAttribute(\"${attribute}\")\\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);\n                    msg.push(`  * Declare \\`static observedAttributes = [\"${attribute}\"]\\` and use \\`attributeChangedCallback(attrName, oldValue, newValue)\\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);\n                }\n                console.error(msg.join('\\n'));\n            }\n        });\n\n        propsHash[propName] = assign({ config: 0 }, props[propName]);\n        return propsHash;\n    }, create(null));\n}\n\nfunction getPublicMethodsHash(target: Object): HashTable<number> {\n    const publicMethods = target.publicMethods;\n    if (!publicMethods || !publicMethods.length) {\n        return EmptyObject;\n    }\n    return publicMethods.reduce((methodsHash: HashTable<number>, methodName: string): HashTable => {\n        methodsHash[methodName] = 1;\n        assert.block(function devModeCheck() {\n            assert.isTrue(isFunction(target.prototype[methodName]), `Component \"${target.name}\" should have a method \\`${methodName}\\` instead of ${target.prototype[methodName]}.`);\n            freeze(target.prototype[methodName]);\n        });\n        return methodsHash;\n    }, create(null));\n}\n\nfunction getObservedAttributesHash(target: Object): HashTable<number> {\n    const observedAttributes = target.observedAttributes;\n    if (!observedAttributes || !observedAttributes.length) {\n        return EmptyObject;\n    }\n    return observedAttributes.reduce((observedAttributes: HashTable<number>, attrName: string): HashTable => {\n        observedAttributes[attrName] = 1;\n        return observedAttributes;\n    }, create(null));\n}\n\nexport function getComponentDef(Ctor: Class<Component>): ComponentDef {\n    let def = CtorToDefMap.get(Ctor);\n    if (def) {\n        return def;\n    }\n    def = createComponentDef(Ctor);\n    CtorToDefMap.set(Ctor, def);\n    return def;\n}\n","import assert from \"./assert\";\nimport { getComponentDef } from \"./def\";\nimport { createComponent, linkComponent } from \"./component\";\nimport { patch } from \"./patch\";\nimport { assign, isArray, toString, ArrayPush, isUndefined, keys } from \"./language\";\nimport { addCallbackToNextTick } from \"./utils\";\n\nlet idx: number = 0;\nlet uid: number = 0;\n\nexport const OwnerKey = Symbol('key');\n\nexport function addInsertionIndex(vm: VM) {\n    assert.vm(vm);\n    assert.invariant(vm.idx === 0, `${vm} is already locked to a previously generated idx.`);\n    vm.idx = ++idx;\n}\n\nexport function removeInsertionIndex(vm: VM) {\n    assert.vm(vm);\n    assert.invariant(vm.idx > 0, `${vm} is not locked to a previously generated idx.`);\n    vm.idx = 0;\n}\n\nexport function createVM(vnode: ComponentVNode) {\n    assert.vnode(vnode);\n    assert.invariant(vnode.elm instanceof HTMLElement, `VM creation requires a DOM element to be associated to vnode ${vnode}.`);\n    const { Ctor } = vnode;\n    const def = getComponentDef(Ctor);\n    console.log(`[object:vm ${def.name}] is being initialized.`);\n    uid += 1;\n    const vm: VM = {\n        uid,\n        idx: 0,\n        isScheduled: false,\n        isDirty: true,\n        def,\n        context: {},\n        cmpProps: {},\n        cmpWired: undefined,\n        cmpState: undefined,\n        cmpSlots: undefined,\n        cmpEvents: undefined,\n        cmpListener: undefined,\n        cmpClasses: undefined,\n        cmpTemplate: undefined,\n        cmpRoot: undefined,\n        classListObj: undefined,\n        component: undefined,\n        vnode,\n        // used to store the latest result of the render method\n        fragment: [],\n        // used to track down all object-key pairs that makes this vm reactive\n        deps: [],\n    };\n    assert.block(function devModeCheck() {\n        vm.toString = (): string => {\n            return `[object:vm ${def.name} (${vm.idx})]`;\n        };\n    });\n    vnode.vm = vm;\n    createComponent(vm, Ctor);\n    linkComponent(vm);\n    assert.block(function devModeCheck() {\n        const { component: { attributeChangedCallback }, def: { observedAttrs } } = vm;\n        if (observedAttrs.length && isUndefined(attributeChangedCallback)) {\n            console.warn(`${vm} has static observedAttributes set to [\"${keys(observedAttrs).join('\", \"')}\"] but it is missing the attributeChangedCallback() method to watch for changes on those attributes. Double check for typos on the name of the callback.`);\n        }\n    });\n    return vm;\n}\n\nexport function relinkVM(vm: VM, vnode: ComponentVNode) {\n    assert.vm(vm);\n    assert.vnode(vnode);\n    assert.isTrue(vnode.elm instanceof HTMLElement, `Only DOM elements can be linked to their corresponding component.`);\n    assert.invariant(vm.component, `vm.component is required to be defined before ${vm} gets linked to ${vnode}.`);\n    vnode.vm = vm;\n    vm.vnode = vnode;\n}\nexport function rehydrate(vm: VM) {\n    assert.vm(vm);\n    if (vm.idx && vm.isDirty) {\n        const { vnode } = vm;\n        assert.isTrue(vnode.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);\n        assert.invariant(isArray(vnode.children), `Rendered ${vm}.children should always have an array of vnodes instead of ${toString(vnode.children)}`);\n        // when patch() is invoked from within the component life-cycle due to\n        // a dirty state, we create a new VNode (oldVnode) with the exact same data was used\n        // to patch this vnode the last time, mimic what happen when the\n        // owner re-renders, but we do so by keeping the vnode originally used by parent\n        // as the source of true, in case the parent tries to rehydrate against that one.\n        const oldVnode = assign({}, vnode);\n        vnode.children = [];\n        patch(oldVnode, vnode);\n    }\n    vm.isScheduled = false;\n}\n\nlet rehydrateQueue: Array<VM> = [];\n\nfunction flushRehydrationQueue() {\n    assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    const vms: Array<VM> = rehydrateQueue.sort((a: VM, b: VM): boolean => a.idx > b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        rehydrate(vms[i]);\n    }\n}\n\nexport function scheduleRehydration(vm: VM) {\n    assert.vm(vm);\n    if (!vm.isScheduled) {\n        vm.isScheduled = true;\n        if (rehydrateQueue.length === 0) {\n            addCallbackToNextTick(flushRehydrationQueue);\n        }\n        ArrayPush.call(rehydrateQueue, vm);\n    }\n}\n\nexport function isNodeOwnedByVM(vm: VM, node: Node): boolean {\n    assert.vm(vm);\n    assert.invariant(node instanceof Node, `isNodeOwnedByVM() should be called with a node as the second argument instead of ${node}`);\n    assert.childNode(vm.vnode.elm, node, `isNodeOwnedByVM() should never be called with a node that is not a child node of ${vm}`);\n    // @ts-ignore\n    return node[OwnerKey] === vm.uid;\n}\n\nexport function wasNodePassedIntoVM(vm: VM, node: Node): boolean {\n    assert.vm(vm);\n    assert.invariant(node instanceof Node, `isNodePassedToVM() should be called with a node as the second argument instead of ${node}`);\n    assert.childNode(vm.vnode.elm, node, `isNodePassedToVM() should never be called with a node that is not a child node of ${vm}`);\n    const { vnode: { uid: ownerUid } } = vm;\n    // TODO: we need to walk the parent path here as well, in case they passed it via slots multiple times\n    // @ts-ignore\n    return node[OwnerKey] === ownerUid;\n}\n","import { createVM, relinkVM } from \"../vm\";\nimport assert from \"../assert\";\nimport { isUndefined } from \"../language\";\n\n// this hook will set up the component instance associated to the new vnode,\n// and link the new vnode with the corresponding component\nfunction initializeComponent(oldVnode: ComponentVNode, vnode: ComponentVNode) {\n    const { Ctor } = vnode;\n    if (isUndefined(Ctor)) {\n        return;\n    }\n    /**\n     * The reason why we do the initialization here instead of prepatch or any other hook\n     * is because the creation of the component does require the element to be available.\n     */\n    assert.invariant(vnode.elm, `${vnode}.elm should be ready.`);\n    if (oldVnode.vm && oldVnode.Ctor === Ctor) {\n        assert.invariant(vnode.elm === oldVnode.elm, `${vnode}.elm should always match the oldVnode's   element.`);\n        relinkVM(oldVnode.vm, vnode);\n    } else {\n        createVM(vnode);\n    }\n    assert.invariant(vnode.vm.component, `vm ${vnode.vm} should have a component and element associated to it.`);\n}\n\nexport default {\n    create: initializeComponent,\n    update: initializeComponent,\n};\n","import {\n    resetComponentProp,\n    updateComponentProp,\n} from \"../component\";\nimport { assign, isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\nfunction syncProps(oldVnode: VNode, vnode: ComponentVNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n\n    let { data: { _props: oldProps } } = oldVnode;\n    let { data: { _props: newProps } } = vnode;\n\n    // infuse key-value pairs from _props into the component\n    if (oldProps !== newProps && (oldProps || newProps)) {\n        let key: string, cur: any;\n        oldProps = oldProps || EmptyObject;\n        newProps = newProps || EmptyObject;\n        // removed props should be reset in component's props\n        for (key in oldProps) {\n            if (!(key in newProps)) {\n                resetComponentProp(vm, key);\n            }\n        }\n\n        // new or different props should be set in component's props\n        for (key in newProps) {\n            cur = newProps[key];\n            if (!(key in oldProps) || oldProps[key] != cur) {\n                updateComponentProp(vm, key, cur);\n            }\n        }\n    }\n\n    // Note: _props, which comes from api.c()'s data.props, is only used to populate\n    //       public props, and any other alien key added to it by the compiler will be\n    //       ignored, and a warning is shown.\n}\n\nexport default {\n    create: syncProps,\n    update: syncProps,\n};\n","import { invokeComponentAttributeChangedCallback } from \"../invoker\";\nimport { isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\nfunction observeAttributes(oldVnode: VNode, vnode: ComponentVNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n    const { def: { observedAttrs } } = vm;\n    if (observedAttrs.length === 0) {\n        return; // nothing to observe\n    }\n\n    let { data: { attrs: oldAttrs } } = oldVnode;\n    let { data: { attrs: newAttrs } } = vnode;\n\n    if (oldAttrs === newAttrs || (isUndefined(oldAttrs) && isUndefined(oldAttrs))) {\n        return;\n    }\n\n    // infuse key-value pairs from _props into the component\n    let key: string, cur: any;\n    oldAttrs = oldAttrs || EmptyObject;\n    newAttrs = newAttrs || EmptyObject;\n    // removed props should be reset in component's props\n    for (key in oldAttrs) {\n        if (key in observedAttrs && !(key in newAttrs)) {\n            invokeComponentAttributeChangedCallback(vm, key, oldAttrs[key], null);\n        }\n    }\n\n    // new or different props should be set in component's props\n    for (key in newAttrs) {\n        if (key in observedAttrs) {\n            cur = newAttrs[key];\n            if (!(key in oldAttrs) || oldAttrs[key] != cur) {\n                invokeComponentAttributeChangedCallback(vm, key, oldAttrs[key], cur);\n            }\n        }\n    }\n}\n\nexport default {\n    create: observeAttributes,\n    update: observeAttributes,\n};\n","import { isUndefined } from \"../language\";\nimport { createComponentListener } from \"../component\";\nimport { EmptyObject } from \"../utils\";\n\nfunction removeAllCmpEventListeners(vnode: VNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n    const { cmpEvents: on, listener } = vm;\n    if (on && listener) {\n        const { elm } = vnode;\n        let name;\n        for (name in on) {\n            elm.removeEventListener(name, listener, false);\n        }\n        vm.listener = undefined;\n    }\n}\n\nfunction updateCmpEventListeners(oldVnode: VNode, vnode: VNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n    const { vm: oldVm } = oldVnode;\n    if (oldVm === vm) {\n        return;\n    }\n\n    const oldOn = (oldVm && oldVm.cmpEvents) || EmptyObject;\n    const { cmpEvents: on = EmptyObject } = vm;\n\n    if (oldOn === on) {\n        return;\n    }\n\n    const { elm } = vnode;\n    const { elm: oldElm } = oldVnode;\n    const listener = vm.cmpListener = (oldVm && oldVm.cmpListener) || createComponentListener();\n    listener.vm = vm;\n\n    let name;\n    for (name in on) {\n        if (isUndefined(oldOn[name])) {\n            elm.addEventListener(name, listener, false);\n        }\n    }\n    for (name in oldOn) {\n        if (isUndefined(on[name])) {\n            oldElm.removeEventListener(name, listener, false);\n        }\n    }\n}\n\n\n\nconst eventListenersModule: Module = {\n    create: updateCmpEventListeners,\n    update: updateCmpEventListeners,\n    destroy: removeAllCmpEventListeners\n};\nexport default eventListenersModule;\n","import { isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\nfunction syncClassNames(oldVnode: VNode, vnode: ComponentVNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n\n    const { vm: oldVm } = oldVnode;\n    if (oldVm === vm) {\n        return;\n    }\n\n    const oldClass = (oldVm && oldVm.cmpClasses) || EmptyObject;\n    const { cmpClasses: klass = EmptyObject } = vm;\n\n    if (oldClass === klass) {\n        return;\n    }\n\n    const { elm, data: { class: ownerClass = EmptyObject } } = vnode;\n\n    let name: string;\n    for (name in oldClass) {\n        // remove only if it was removed from within the instance and it is not set from owner\n        if (oldClass[name] && !klass[name] && !ownerClass[name]) {\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        if (klass[name] && !oldClass[name]) {\n            elm.classList.add(name);\n        }\n    }\n}\n\nexport default {\n    create: syncClassNames,\n    update: syncClassNames,\n};\n","import {\n    addComponentSlot,\n    removeComponentSlot,\n} from \"../component\";\nimport { isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\nfunction update(oldVnode: VNode, vnode: ComponentVNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n\n    let { data: { slotset: oldSlots } } = oldVnode;\n    let { data: { slotset: newSlots } } = vnode;\n\n    // infuse key-value pairs from slotset into the component\n    if (oldSlots !== newSlots && (oldSlots || newSlots)) {\n        let key: string, cur: any;\n        oldSlots = oldSlots || EmptyObject;\n        newSlots = newSlots || EmptyObject;\n        // removed slots should be removed from component's slotset\n        for (key in oldSlots) {\n            if (!(key in newSlots)) {\n                removeComponentSlot(vm, key);\n            }\n        }\n\n        // new or different slots should be set in component's slotset\n        for (key in newSlots) {\n            cur = newSlots[key];\n            if (!(key in oldSlots) || oldSlots[key] != cur) {\n                if (cur && cur.length) {\n                    addComponentSlot(vm, key, cur);\n                } else {\n                    removeComponentSlot(vm, key);\n                }\n            }\n        }\n    }\n}\n\nexport default {\n    create: update,\n    update,\n};\n","import assert from \"../assert\";\nimport { renderComponent } from \"../component\";\nimport { isUndefined, ArrayPush } from \"../language\";\n\nfunction rerender(oldVnode: VNode, vnode: ComponentVNode) {\n    const { vm } = vnode;\n    if (isUndefined(vm)) {\n        return;\n    }\n    const { children } = vnode;\n    // if diffing is against an inserted VM, it means the element is already\n    // in the DOM and we can compute its body.\n    if (vm.idx && vm.isDirty) {\n        assert.invariant(oldVnode.children !== children, `If component is dirty, the children collections must be different. In theory this should never happen.`);\n        renderComponent(vm);\n    }\n    // replacing the vnodes in the children array without replacing the array itself\n    // because the engine has a hard reference to the original array object.\n    children.length = 0;\n    ArrayPush.apply(children, vm.fragment);\n}\n\nexport default {\n    create: rerender,\n    update: rerender,\n};\n","import assert from \"../assert\";\nimport { isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\n// TODO: eventually use the one shipped by snabbdom directly\nfunction update(oldVnode: VNode, vnode: VNode) {\n    let oldProps = oldVnode.data.props;\n    let props = vnode.data.props;\n\n    if (isUndefined(oldProps) && isUndefined(props)) {\n        return;\n    }\n    if (oldProps === props) {\n        return;\n    }\n\n    oldProps = oldProps || EmptyObject;\n    props = props || EmptyObject;\n\n    let key: string, cur: any, old: any;\n    const { elm } = vnode;\n\n    for (key in oldProps) {\n        if (!(key in props)) {\n            if (vnode.isRoot) {\n                // custom elements created programatically prevent you from\n                // deleting the property because it has a set/get to update\n                // the corresponding component, in this case, we just set it\n                // to undefined, which has the same effect.\n                elm[key] = undefined;\n            } else {\n                delete elm[key];\n            }\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n\n        if (old !== cur) {\n            if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n                // only touching the dom if the prop really changes.\n                assert.block(function devModeCheck() {\n                    if (elm[key] === cur && old !== undefined && !vnode.isRoot) {\n                        console.warn(`Unneccessary update of property \"${key}\" in ${elm}, it has the same value in ${vnode.vm || vnode}.`);\n                    }\n                });\n                elm[key] = cur;\n            }\n        }\n    }\n}\n\nexport default {\n    create: update,\n    update,\n};\n","export var array = Array.isArray;\nexport function primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\n","function createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.nodeValue = text;\n}\nfunction getTextContent(node) {\n    return node.nodeValue;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    // Performance optimization over `return node.nodeType === 3;`\n    return node.splitText !== undefined;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexport var htmlDomApi = {\n    createElement: createElement,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    getTextContent: getTextContent,\n    isElement: isElement,\n    isText: isText,\n    isComment: isComment,\n};\nexport default htmlDomApi;\n","import { v as vnode } from '../../framework/api';\nimport * as is from './is';\nimport htmlDomApi from './htmldomapi';\nfunction isUndef(s) { return s === undefined; }\nfunction isDef(s) { return s !== undefined; }\nvar emptyNode = { sel: \"\", data: {}, children: [] };\nfunction sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVnode(vnode) {\n    return vnode.sel !== undefined;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, map = {}, key, ch;\n    for (i = beginIdx; i <= endIdx; ++i) {\n        ch = children[i];\n        if (ch != null) {\n            key = ch.key;\n            if (key !== undefined)\n                map[key] = i;\n        }\n    }\n    return map;\n}\nvar hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\n// export { h } from './h';\n// export { thunk } from './thunk';\nexport function init(modules, domApi) {\n    var i, j, cbs = {};\n    var api = domApi !== undefined ? domApi : htmlDomApi;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            var hook = modules[j][hooks[i]];\n            if (hook !== undefined) {\n                cbs[hooks[i]].push(hook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        var id = elm.id ? '#' + elm.id : '';\n        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                var parent_1 = api.parentNode(childElm);\n                api.removeChild(parent_1, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var i, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.init)) {\n                i(vnode);\n                data = vnode.data;\n            }\n        }\n        var children = vnode.children, sel = vnode.sel;\n        if (sel === '!') {\n            if (isUndef(vnode.text)) {\n                vnode.text = '';\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            var hashIdx = sel.indexOf('#');\n            var dotIdx = sel.indexOf('.', hashIdx);\n            var hash = hashIdx > 0 ? hashIdx : sel.length;\n            var dot = dotIdx > 0 ? dotIdx : sel.length;\n            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)\n                : api.createElement(tag);\n            if (hash < dot)\n                elm.id = sel.slice(hash + 1, dot);\n            if (dotIdx > 0)\n                elm.className = sel.slice(dot + 1).replace(/\\./g, ' ');\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    var ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (is.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            i = vnode.data.hook; // Reuse variable\n            if (isDef(i)) {\n                if (i.create)\n                    i.create(emptyNode, vnode);\n                if (i.insert)\n                    insertedVnodeQueue.push(vnode);\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var i, j, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.destroy))\n                i(vnode);\n            for (i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (j = 0; j < vnode.children.length; ++j) {\n                    i = vnode.children[j];\n                    if (i != null && typeof i !== \"string\") {\n                        invokeDestroyHook(i);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)\n                        cbs.remove[i_1](ch, rm);\n                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {\n                        i_1(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else {\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        var oldStartIdx = 0, newStartIdx = 0;\n        var oldEndIdx = oldCh.length - 1;\n        var oldStartVnode = oldCh[0];\n        var oldEndVnode = oldCh[oldEndIdx];\n        var newEndIdx = newCh.length - 1;\n        var newStartVnode = newCh[0];\n        var newEndVnode = newCh[newEndIdx];\n        var oldKeyToIdx;\n        var idxInOld;\n        var elmToMove;\n        var before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (oldStartIdx > oldEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        else if (newStartIdx > newEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var i, hook;\n        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n            i(oldVnode, vnode);\n        }\n        var elm = vnode.elm = oldVnode.elm;\n        var oldCh = oldVnode.children;\n        var ch = vnode.children;\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined) {\n            for (i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            i = vnode.data.hook;\n            if (isDef(i) && isDef(i = i.update))\n                i(oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            api.setTextContent(elm, vnode.text);\n        }\n        if (isDef(hook) && isDef(i = hook.postpatch)) {\n            i(oldVnode, vnode);\n        }\n    }\n    return function patch(oldVnode, vnode) {\n        var i, elm, parent;\n        var insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (!isVnode(oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n","const xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\nconst XCharCode = 120;\n\nfunction updateAttrs(oldVnode: VNode, vnode: VNode) {\n    let { data: { attrs: oldAttrs } } = oldVnode;\n    let { data: { attrs } } = vnode;\n\n    if (!oldAttrs && !attrs) {\n        return;\n    }\n    if (oldAttrs === attrs) {\n        return;\n    }\n    const { elm } = vnode;\n    let key: string;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            } else if (cur === false) {\n                elm.removeAttribute(key);\n            } else {\n                if (key.charCodeAt(0) !== XCharCode) {\n                    elm.setAttribute(key, cur);\n                } else if (key.charCodeAt(3) === ColonCharCode) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                } else if (key.charCodeAt(5) === ColonCharCode) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                } else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\n\nconst attributesModule: Module = {\n    create: updateAttrs,\n    update: updateAttrs\n};\nexport default attributesModule;\n","const DashCharCode = 45;\n\nfunction updateStyle(oldVnode: VNode, vnode: VNode) {\n    let { data: { style: oldStyle } } = oldVnode;\n    let { data: { style } } = vnode;\n\n    if (!oldStyle && !style) {\n        return;\n    }\n    if (oldStyle === style) {\n        return;\n    }\n    oldStyle = oldStyle || {};\n    style = style || {};\n\n    let name: string;\n    const { elm } = vnode;\n    for (name in oldStyle) {\n        if (!(name in style)) {\n            elm.style.removeProperty(name);\n        }\n    }\n    for (name in style) {\n        const cur = style[name];\n        if (cur !== oldStyle[name]) {\n            if (name.charCodeAt(0) === DashCharCode && name.charCodeAt(1) === DashCharCode) {\n                // if the name is prefied with --, it will be considered a variable, and setProperty() is needed\n                elm.style.setProperty(name, cur);\n            } else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\n\nconst styleModule: Module = {\n    create: updateStyle,\n    update: updateStyle,\n};\nexport default styleModule;\n","import { EmptyObject } from \"../utils\";\n\nfunction updateClass(oldVnode: VNode, vnode: VNode) {\n    const { data: { class: oldClass = EmptyObject } } = oldVnode;\n    const { elm, data: { class: klass = EmptyObject } } = vnode;\n\n    if (oldClass === klass) {\n        return;\n    }\n\n    const innerClass = (vnode.vm && vnode.vm.cmpClasses) || EmptyObject;\n\n    let name: string\n    for (name in oldClass) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (!klass[name] && !innerClass[name]) {\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        if (!oldClass[name]) {\n            elm.classList.add(name);\n        }\n    }\n}\n\nexport default {\n    create: updateClass,\n    update: updateClass\n};\n","import { isUndefined } from \"../language\";\nimport { EmptyObject } from \"../utils\";\n\nfunction handleEvent(event: Event, vnode: VNode) {\n    const { type } = event;\n    const { data: { on } } = vnode;\n    let handler = on && on[type];\n    // call event handler if exists\n    if (handler) {\n        handler.call(undefined, event);\n    }\n}\n\nfunction createListener(): EventListener {\n    return function handler(event: Event) {\n        handleEvent(event, handler.vnode);\n    }\n}\n\nfunction removeAllEventListeners(vnode: VNode) {\n    const { data: { on }, listener } = vnode;\n    if (on && listener) {\n        const { elm } = vnode;\n        let name;\n        for (name in on) {\n            elm.removeEventListener(name, listener, false);\n        }\n        vnode.listener = undefined;\n    }\n}\n\nfunction updateEventListeners(oldVnode: VNode, vnode: VNode) {\n    const { data: { on: oldOn = EmptyObject } } = oldVnode;\n    const { data: { on = EmptyObject } } = vnode;\n\n    if (oldOn === on) {\n        return;\n    }\n\n    const { elm } = vnode;\n    const { elm: oldElm } = oldVnode;\n    const listener = vnode.listener = oldVnode.listener || createListener();\n    listener.vnode = vnode;\n\n    let name;\n    for (name in on) {\n        if (isUndefined(oldOn[name])) {\n            elm.addEventListener(name, listener, false);\n        }\n    }\n    for (name in oldOn) {\n        if (isUndefined(on[name])) {\n            oldElm.removeEventListener(name, listener, false);\n        }\n    }\n}\n\nconst eventListenersModule: Module = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: removeAllEventListeners\n};\nexport default eventListenersModule;\n","import { OwnerKey } from \"../vm\";\n\nfunction updateUID(oldVnode: VNode, vnode: VNode) {\n    const { uid: oldUid } = oldVnode;\n    const { elm, uid } = vnode;\n    if (uid === oldUid) {\n        return;\n    }\n    // @ts-ignore\n    elm[OwnerKey] = uid;\n}\n\nconst uidModule: Module = {\n    create: updateUID,\n    update: updateUID,\n};\nexport default uidModule;\n","import assert from \"./assert\";\nimport { patch } from \"./patch\";\nimport { scheduleRehydration } from \"./vm\";\nimport { invokeComponentAttributeChangedCallback } from \"./invoker\";\nimport { updateComponentProp } from \"./component\";\nimport { getComponentDef } from \"./def\";\nimport { c } from \"./api\";\nimport { isUndefined, isFunction } from \"./language\";\nimport { getPropNameFromAttrName } from \"./utils\";\n\nconst { getAttribute, setAttribute, removeAttribute } = Element.prototype;\n\nfunction linkAttributes(element: HTMLElement, vm: VM) {\n    assert.vm(vm);\n    const { def: { props: propsConfig, observedAttrs } } = vm;\n    // replacing mutators and accessors on the element itself to catch any mutation\n    element.getAttribute = (attrName: string): string | null => {\n        attrName = attrName.toLocaleLowerCase();\n        const propName = getPropNameFromAttrName(attrName);\n        if (propsConfig[propName]) {\n            assert.logError(`Invalid attribute \"${attrName}\" for ${vm}. Instead access the public property with \\`element.${propName};\\`.`);\n            return;\n        }\n        return getAttribute.call(element, attrName);\n    };\n    element.setAttribute = (attrName: string, newValue: any) => {\n        attrName = attrName.toLocaleLowerCase();\n        const propName = getPropNameFromAttrName(attrName);\n        if (propsConfig[propName]) {\n            assert.error(`Invalid attribute \"${attrName}\" for ${vm}. Instead update the public property with \\`element.${propName} = value;\\`.`);\n            return;\n        }\n        const oldValue = getAttribute.call(element, attrName);\n        setAttribute.call(element, attrName, newValue);\n        newValue = getAttribute.call(element, attrName);\n        if (attrName in observedAttrs && oldValue !== newValue) {\n            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);\n        }\n    };\n    element.removeAttribute = (attrName: string) => {\n        attrName = attrName.toLocaleLowerCase();\n        const propName = getPropNameFromAttrName(attrName);\n        if (propsConfig[propName]) {\n            assert.logError(`Invalid attribute \"${attrName}\" for ${vm}. Instead update the public property with \\`element.${propName} = undefined;\\`.`);\n            return;\n        }\n\n        assert.block(function devModeCheck() {\n            const propName = getPropNameFromAttrName(attrName);\n            if (propsConfig[propName]) {\n                updateComponentProp(vm, propName, newValue);\n                if (vm.isDirty) {\n                    console.log(`Scheduling ${vm} for rehydration.`);\n                    scheduleRehydration(vm);\n                }\n            }\n        });\n        const oldValue = getAttribute.call(element, attrName);\n        removeAttribute.call(element, attrName);\n        const newValue = getAttribute.call(element, attrName);\n        if (attrName in observedAttrs && oldValue !== newValue) {\n            invokeComponentAttributeChangedCallback(vm, attrName, oldValue, newValue);\n        }\n    };\n}\n\nfunction getInitialProps(element: HTMLElement, Ctor: Class<Component>): HashTable<any> {\n    const { props: config } = getComponentDef(Ctor);\n    const props = {};\n    for (let propName in config) {\n        if (propName in element) {\n            props[propName] = element[propName];\n        }\n    }\n    return props;\n}\n\nfunction getInitialSlots(element: HTMLElement, Ctor: Class<Component>): HashTable<any> {\n    const { slotNames } = getComponentDef(Ctor);\n    if (isUndefined(slotNames)) {\n        return;\n    }\n    // TODO: implement algo to resolve slots\n    return undefined;\n}\n\n/**\n * This algo mimics 2.5 of web component specification somehow:\n * https://www.w3.org/TR/custom-elements/#upgrades\n */\nfunction upgradeElement(element: HTMLElement, Ctor: Class<Component>) {\n    if (isUndefined(Ctor)) {\n        throw new TypeError(`Invalid Component Definition: ${Ctor}.`);\n    }\n    const props = getInitialProps(element, Ctor);\n    const slotset = getInitialSlots(element, Ctor);\n    const tagName = element.tagName.toLowerCase();\n    const vnode = c(tagName, Ctor, { props, slotset, className: element.className || undefined });\n    vnode.isRoot = true;\n    // TODO: eventually after updating snabbdom we can use toVNode(element)\n    // as the first argument to reconstruct the vnode that represents the\n    // current state.\n    const { vm } = patch(element, vnode);\n    linkAttributes(element, vm);\n}\n\n/**\n * This method is almost identical to document.createElement\n * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)\n * with the slightly difference that in the options, you can pass the `is`\n * property set to a Constructor instead of just a string value. E.g.:\n *\n * const el = createElement('x-foo', { is: FooCtor });\n *\n * If the value of `is` attribute is not a constructor,\n * then we fallback to the normal Web-Components workflow.\n */\nexport function createElement(tagName: string, options: any = {}): HTMLElement {\n    const Ctor = isFunction(options.is) ? options.is : null;\n    const element = document.createElement(tagName, Ctor ? null : options);\n\n    if (Ctor && element instanceof HTMLElement) {\n        upgradeElement(element, Ctor);\n    }\n    return element;\n}\n\n// TODO: how can a user dismount a component and kick in the destroy mechanism?\n","// Few more execptions that are using the attribute name to match the property in lowercase.\n// this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx\n// and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n// Note: this list most be in sync with the compiler as well.\nexport const HTMLPropertyNamesWithLowercasedReflectiveAttributes = [\n    'accessKey',\n    'readOnly',\n    'tabIndex',\n    'bgColor',\n    'colSpan',\n    'rowSpan',\n    'contentEditable',\n    'dateTime',\n    'formAction',\n    'isMap',\n    'maxLength',\n    'useMap',\n];\n\n// Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\nexport const GlobalHTMLProperties = {\n    accessKey: {\n        attribute: 'accesskey',\n    },\n    accessKeyLabel: {\n        readOnly: true,\n    },\n    className: {\n        attribute: 'class',\n        error: `Using property \"className\" is an anti-pattern because of slow runtime behavior and conflicting with classes provided by the owner element. Instead use property \"classList\".`,\n    },\n    contentEditable: {\n        attribute: 'contenteditable',\n    },\n    isContentEditable: {\n        readOnly: true,\n    },\n    contextMenu: {\n        attribute: 'contextmenu',\n    },\n    dataset: {\n        readOnly: true,\n        msg: 'Using property \"dataset\" is an anti-pattern. Instead declare \\`static observedAttributes = [\"data-foo\"]\\` and use \\`attributeChangedCallback(attrName, oldValue, newValue)\\` to get a notification each time the attribute changes.',\n    },\n    dir: {\n        attribute: 'dir',\n    },\n    draggable: {\n        attribute: 'draggable',\n        experimental: true,\n    },\n    dropzone: {\n        attribute: 'dropzone',\n        readOnly: true,\n        experimental: true,\n    },\n    hidden: {\n        attribute: 'hidden',\n    },\n    itemScope: {\n        attribute: 'itemscope',\n        experimental: true,\n    },\n    itemType: {\n        attribute: 'itemtype',\n        readOnly: true,\n        experimental: true,\n    },\n    itemId: {\n        attribute: 'itemid',\n        experimental: true,\n    },\n    itemRef: {\n        attribute: 'itemref',\n        readOnly: true,\n        experimental: true,\n    },\n    itemProp: {\n        attribute: 'itemprop',\n        readOnly: true,\n        experimental: true,\n    },\n    itemValue: {\n        experimental: true,\n    },\n    lang: {\n        attribute: 'lang',\n    },\n    offsetHeight: {\n        readOnly: true,\n        experimental: true,\n    },\n    offsetLeft: {\n        readOnly: true,\n        experimental: true,\n    },\n    offsetParent: {\n        readOnly: true,\n        experimental: true,\n    },\n    offsetTop: {\n        readOnly: true,\n        experimental: true,\n    },\n    offsetWidth: {\n        readOnly: true,\n        experimental: true,\n    },\n    properties: {\n        readOnly: true,\n        experimental: true,\n    },\n    spellcheck: {\n        experimental: true,\n    },\n    style: {\n        attribute: 'style',\n        error: `Using property or attribute \"style\" is an anti-pattern. Instead use property \"classList\".`,\n    },\n    tabIndex: {\n        attribute: 'tabindex',\n    },\n    title: {\n        attribute: 'title',\n    },\n    translate: {\n        experimental: true,\n    },\n    // additional global attributes that are not present in the link above.\n    role: {\n        attribute: 'role',\n    },\n    slot: {\n        attribute: 'slot',\n        experimental: true,\n        error: `Using property or attribute \"slot\" is an anti-pattern.`\n    }\n};\n\n// TODO: complete this list with Element properties\n// https://developer.mozilla.org/en-US/docs/Web/API/Element\n\n// TODO: complete this list with Node properties\n// https://developer.mozilla.org/en-US/docs/Web/API/Node\n","import componentInit from \"./modules/component-init\";\nimport componentProps from \"./modules/component-props\";\nimport componentAttrs from \"./modules/component-attrs\";\nimport componentEvents from \"./modules/component-events\";\nimport componentClasses from \"./modules/component-classes\";\nimport componentSlotset from \"./modules/component-slotset\";\nimport componentChildren from \"./modules/component-children\";\nimport props from \"./modules/props\";\n\nimport { init } from \"../3rdparty/snabbdom/snabbdom\";\nimport attrs from \"./modules/attrs\";\nimport styles from \"./modules/styles\";\nimport classes from \"./modules/classes\";\nimport events from \"./modules/events\";\nimport uid from \"./modules/uid\";\n\nexport const patch = init([\n    componentInit,\n    componentSlotset,\n    componentProps,\n    componentAttrs,\n    componentEvents,\n    componentClasses,\n    componentChildren,\n    props,\n    attrs,\n    classes,\n    styles,\n    events,\n    uid,\n]);\n"],"names":["obj","undefined","Promise","resolve","classList","ViewModelReflection","vnode","elm","vm","defineProperty","this","value","writable","enumerable","configurable","ctx","currentContext","callbacks","nextTickCallbackQueue","i","len","length","callback","then","flushCallbackQueue","ArrayPush","call","attrName","propName","attrNameToPropNameMap","replace","CAMEL_REGEX","g","toUpperCase","propNameToAttributeNameMap","CAPS_REGEX","match","toLowerCase","raw","className","map","classNameToClassMap","start","charCodeAt","SPACE_CHAR","slice","service","hooks","hookName","l","Services","isUndefined","push","cbs","component","data","def","context","addInsertionIndex","isDirty","connectedCallback","rehydrate","connected","addCallbackToNextTick","invokeServiceHook","noop","invokeComponentMethod","removeInsertionIndex","disconnected","disconnectedCallback","clearListeners","oldVnode","idx","insert","children","sel","ns","NamespaceAttributeForSVG","i_1","child","data_1","grandChildren","addNS","text","Ctor","EmptyData","key","uid","vmBeingRendered","classMap","class","getMapFromClassName","CHAR_S","CHAR_V","CHAR_G","v","__circular__","slotset","attrs","on","_props","hook","items","factory","isArray","list","i_2","apply","flattened","i_3","item","fn","event","invokeComponentCallback","handler","target","reactiveRecord","TargetToReactiveRecordMap","get","markComponentAsDirty","scheduleRehydration","newRecord","create","set","ArrayIndexOf","deps","isRendering","subscribeToSetHook","isObject","getPropertyProxy","notifyListeners","isNull","constructor","Date","ProxyCache","has","proxy","ObjectPropertyToProxyCache","Proxy","propertyProxyHandler","add","slotName","html","_a","cmpSlots","tplCache","cmpTemplate","_b","slotsetRevoke","_c","cmp","componentRevoke","outerMemoized","currentMemoized","vnodes","api","originalPromise","tplPromise","isFunction","tplResolvedValue","attemptToEvaluateResolvedTemplate","evaluateTemplate","fnCtx","args","establishContext","result","error","e","methodName","isRenderingInception","vmBeingRenderedInception","render","isPromise","deferredTemplate","oldValue","newValue","attributeChangedCallback","vmBeingConstructed","vmBeingConstructedInception","invokeComponentConstructor","publicMethodsConfig","publicProps","descriptors","getter","bind","setter","isRoot","updateComponentProp","defineProperties","wiring","pos","ArraySplice","cmpProps","observedAttrs","propDef","getAttrNameFromPropName","invokeComponentAttributeChangedCallback","publicPropsConfig","dispatchComponentEvent","eventName","newHandler","cmpEvents","cmpListener","createComponentListener","addEventListener","oldHandler","handlers","type","uninterrupted","stopImmediatePropagation","invokeComponentRenderMethod","fragment","renderedCallback","rehydrated","isCompatMode","membrane","isReplicable","cells","cache","r","replica","replicaOrAny","TargetSlot","shouldReturn","compat","unwrap","MembraneSlot","deleteProperty","piercing","result_1","next_1","PiercingMembraneHandler","Membrane","getReplica","root","shadowRoot","selector","pierce","getLinkedElement","querySelector","querySelectorAll","nodeList","isNodeOwnedByVM","filteredNodes","ArrayFilter","node","selectors","originalPropertyDescriptor","origGetter","isBeingConstructed","origSetter","cmpWired","name","props","getPublicPropertiesHash","methods","getPublicMethodsHash","getObservedAttributesHash","wire","getWireHash","proto","prototype","descriptor","getOwnPropertyDescriptor","config","COMPUTED_GETTER_MASK","COMPUTED_SETTER_MASK","createPublicPropertyDescriptor","method","createWiredPropertyDescriptor","superProto","getPrototypeOf","Element","superDef","getComponentDef","assign","getOwnPropertyNames","reduce","propsHash","EmptyObject","publicMethods","methodsHash","observedAttributes","CtorToDefMap","createComponentDef","isScheduled","cmpState","cmpClasses","cmpRoot","classListObj","createComponent","linkComponent","patch","vms","rehydrateQueue","sort","a","b","flushRehydrationQueue","OwnerKey","ownerUid","relinkVM","createVM","oldProps","newProps","cur","resetComponentProp","oldAttrs","newAttrs","listener","removeEventListener","oldVm","oldOn","oldElm","oldClass","klass","ownerClass","remove","oldSlots","newSlots","removeComponentSlot","addComponentSlot","renderComponent","old","s","tagName","document","createElement","namespaceURI","qualifiedName","createElementNS","createTextNode","createComment","parentNode","newNode","referenceNode","insertBefore","removeChild","appendChild","nextSibling","nodeValue","nodeType","splitText","vnode1","vnode2","beginIdx","endIdx","ch","setAttribute","removeAttribute","XCharCode","ColonCharCode","setAttributeNS","xmlNS","xlinkNS","oldStyle","style","removeProperty","DashCharCode","setProperty","innerClass","handleEvent","createListener","oldUid","element","propsConfig","getAttribute","toLocaleLowerCase","getPropNameFromAttrName","TypeError","getInitialProps","getInitialSlots","c","linkAttributes","options","is","HTMLElement","upgradeElement","freeze","seal","Array","ArrayMap","forEach","HTMLPropertyNamesWithLowercasedReflectiveAttributes","ClassList","arguments","index","filter","toggle","force","contains","toString","join","topLevelContextSymbol","Symbol","htmlFor","lifeCycleHooks","destroy","postpatch","WeakMap","WeakSet","propertyGetter","propertySetter","propertyDelete","EmptySlots","slotsetProxyHandler","getSlotsetValue","cmpProxyHandler","thisArg","argumentsList","newTarget","construct","piercingHook","targetFn","Root","mode","host","shadowRootQuerySelector","shadowRootQuerySelectorAll","register","getFirstMatch","getAllMatches","isParentNodeKeyword","ComponentElement","dispatchEvent","addComponentEventListener","removeComponentEventListener","toAttributeValue","getBoundingClientRect","querySelectorAllFromComponent","wasNodePassedIntoVM","state","newState","initializeComponent","update","syncProps","observeAttributes","eventListenersModule","updateCmpEventListeners","removeAllCmpEventListeners","syncClassNames","rerender","array","htmlDomApi","setTextContent","getTextContent","isElement","isText","isComment","emptyNode","attributesModule","updateAttrs","styleModule","updateStyle","updateClass","updateEventListeners","removeAllEventListeners","uidModule","updateUID","modules","domApi","id","split","childElm","listeners","parent_1","insertedVnodeQueue","isDef","init","isUndef","hashIdx","indexOf","dotIdx","hash","dot","tag","Math","min","is.array","createElm","is.primitive","parentElm","before","startIdx","j","invokeDestroyHook","rm","createRmCb","oldCh","newCh","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","sameVnode","patchVnode","createKeyToOldIdx","addVnodes","removeVnodes","prepatch","updateChildren","parent","pre","isVnode","emptyNodeAt","post","componentInit","componentSlotset","componentProps","componentAttrs","componentEvents","componentClasses","componentChildren","classes","styles","events"],"mappings":"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"}